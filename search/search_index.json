{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Formation PostGIS # Pr\u00e9-requis # Cette formation concerne des utilisateurs de QGIS, g\u00e9omaticiens, qui souhaitent comprendre l'apport de l'utilisation de PostgreSQL comme outil de centralisation de la donn\u00e9es spatiale (et non spatiale): un lieu unique de stockage une gestion des droits d'acc\u00e8s (lecture, \u00e9criture) la reproduction de quasiment tous les besoins en traitements SIG : intersections, tampons, extraction, correction, etc. une grande souplesse de manipulation des donn\u00e9es des performances \u00e9lev\u00e9s sur certains traitements spatiaux (et non spatiaux) le stockage de fonctions et de triggers pour assurer la coh\u00e9rence des donn\u00e9es, stocker des outils directement dans la base Sommaire # Liens utiles et jeu de donn\u00e9es Gestion des donn\u00e9es PostgreSQL dans QGIS Import des donn\u00e9es dans PostgreSQL S\u00e9lectionner des donn\u00e9es: SELECT R\u00e9aliser des calculs et cr\u00e9er des g\u00e9om\u00e9tries: FONCTIONS Filtrer des donn\u00e9es: WHERE Regrouper des donn\u00e9es: GROUP BY Rassembler des donn\u00e9es: UNION ALL Enregistrer les requ\u00eates: VIEW R\u00e9aliser des jointures attributaires et spatiales; JOIN Fusionner des g\u00e9om\u00e9tries Les triggers Correction des g\u00e9om\u00e9tries invalides V\u00e9rifier la topologie Fonctions utiles Gestion des droits Acc\u00e9der \u00e0 des donn\u00e9es externes: Foreign Data Wrapper Tutoriels en ligne","title":"Accueil"},{"location":"#formation-postgis","text":"","title":"Formation PostGIS"},{"location":"#pre-requis","text":"Cette formation concerne des utilisateurs de QGIS, g\u00e9omaticiens, qui souhaitent comprendre l'apport de l'utilisation de PostgreSQL comme outil de centralisation de la donn\u00e9es spatiale (et non spatiale): un lieu unique de stockage une gestion des droits d'acc\u00e8s (lecture, \u00e9criture) la reproduction de quasiment tous les besoins en traitements SIG : intersections, tampons, extraction, correction, etc. une grande souplesse de manipulation des donn\u00e9es des performances \u00e9lev\u00e9s sur certains traitements spatiaux (et non spatiaux) le stockage de fonctions et de triggers pour assurer la coh\u00e9rence des donn\u00e9es, stocker des outils directement dans la base","title":"Pr\u00e9-requis"},{"location":"#sommaire","text":"Liens utiles et jeu de donn\u00e9es Gestion des donn\u00e9es PostgreSQL dans QGIS Import des donn\u00e9es dans PostgreSQL S\u00e9lectionner des donn\u00e9es: SELECT R\u00e9aliser des calculs et cr\u00e9er des g\u00e9om\u00e9tries: FONCTIONS Filtrer des donn\u00e9es: WHERE Regrouper des donn\u00e9es: GROUP BY Rassembler des donn\u00e9es: UNION ALL Enregistrer les requ\u00eates: VIEW R\u00e9aliser des jointures attributaires et spatiales; JOIN Fusionner des g\u00e9om\u00e9tries Les triggers Correction des g\u00e9om\u00e9tries invalides V\u00e9rifier la topologie Fonctions utiles Gestion des droits Acc\u00e9der \u00e0 des donn\u00e9es externes: Foreign Data Wrapper Tutoriels en ligne","title":"Sommaire"},{"location":"check_topology/","text":"V\u00e9rifier la topologie # D\u00e9placer les noeuds sur une grille # Avant de v\u00e9rifier la topologie, il faut au pr\u00e9alable avoir des g\u00e9om\u00e9tries valides (cf. chapitre pr\u00e9c\u00e9dent). Certaines micro-erreurs de topologie peuvent peuvent \u00eatre corrig\u00e9es en r\u00e9alisant une simplification des donn\u00e9es \u00e0 l'aide d'une grille, par exemple pour corriger des soucis d'arrondis. Pour cela, PostGIS a une fonction ST_SnapToGrid . On peut utiliser conjointement ST_Simplify et ST_SnapToGrid pour effectuer une premi\u00e8re correction sur les donn\u00e9es. Attention, ces fonctions modifient la donn\u00e9e. A vous de choisir la bonne tol\u00e9rance, par exemple 5 cm, qui d\u00e9pend de votre donn\u00e9e et de votre cas d'utilisation. Tester la simplification en lan\u00e7ant la requ\u00eate suivante, et en chargeant le r\u00e9sultat comme une nouvelle couche dans QGIS 1 2 3 4 5 6 7 8 9 10 11 12 13 14 SELECT ST_Multi ( ST_CollectionExtract ( ST_MakeValid ( ST_SnapToGrid ( st_simplify ( geom , 0 ), 0 . 05 -- 5 cm ) ), 3 ) ):: geometry ( multipolygon , 2154 ) FROM z_formation . parcelle_havre ; Une fois le r\u00e9sultat visuellement test\u00e9 dans QGIS, par comparaison avec la table source, on peut choisir de modifier la g\u00e9om\u00e9trie de la table avec la version simplifi\u00e9e des donn\u00e9es: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 -- Parcelles UPDATE z_formation . parcelle_havre SET geom = ST_Multi ( ST_CollectionExtract ( ST_MakeValid ( ST_SnapToGrid ( st_simplify ( geom , 0 ), 0 . 05 -- 5 cm ) ), 3 ) ) ; ; Attention: Si vous avez d'autres tables avec des objets en relation spatiale avec cette table, il faut aussi effectuer le m\u00eame traitement pour que les g\u00e9om\u00e9tries de toutes les couches se calent sur la m\u00eame grille. Par exemple la table des zonages. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 UPDATE z_formation . zone_urba SET geom = ST_Multi ( ST_CollectionExtract ( ST_MakeValid ( ST_SnapToGrid ( st_simplify ( geom , 0 ), 0 . 05 -- 5 cm ) ), 3 ) ) ; Rep\u00e9rer certaines erreurs de topologies # PostGIS poss\u00e8de de nombreuses fonctions de relations spatiales qui permettent de trouver les objets qui se chevauchent, qui se touchent, etc. Ces fonctions peuvent \u00eatre utilis\u00e9es pour comparer les objets d'une m\u00eame table, ou de deux tables diff\u00e9rentes. Voir: https://postgis.net/docs/reference.html#Spatial_Relationships_Measurements Par exemple, trouver les parcelles voisines qui se recouvrent: on utilise la fonction ST_Overlaps . On peut cr\u00e9er une couche listant les recouvrements: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 DROP TABLE IF EXISTS z_formation . recouvrement_parcelle_voisines ; CREATE TABLE z_formation . recouvrement_parcelle_voisines AS SELECT DISTINCT ON ( geom ) parcelle_a , parcelle_b , aire_a , aire_b , ST_Area ( geom ) AS aire , geom FROM ( SELECT a . id_parcelle AS parcelle_a , ST_Area ( a . geom ) AS aire_a , b . id_parcelle AS parcelle_b , ST_Area ( b . geom ) AS aire_b , ( ST_Multi ( st_collectionextract ( ST_MakeValid ( ST_Intersection ( a . geom , b . geom )) , 3 ) )):: geometry ( MultiPolygon , 2154 ) AS geom FROM z_formation . parcelle_havre AS a JOIN z_formation . parcelle_havre AS b ON a . id_parcelle != b . id_parcelle --ON ST_Intersects(a.geom, b.geom) AND ST_Overlaps ( a . geom , b . geom ) ) AS voisin ORDER BY geom ; CREATE INDEX ON z_formation . recouvrement_parcelle_voisines USING GIST ( geom ); On peut alors ouvrir cette couche dans QGIS pour zoomer sur chaque objet de recouvrement. R\u00e9cup\u00e9rer la liste des identifiants de ces parcelles: 1 SELECT string_agg ( parcelle_a :: text , ',' ) FROM z_formation . recouvrement_parcelle_voisines ; On peut utiliser le r\u00e9sultat de cette requ\u00eate pour s\u00e9lectionner les parcelles probl\u00e9matiques: on s\u00e9lectionne le r\u00e9sultat dans le tableau du gestionnaire de base de donn\u00e9es, et on copie (CTRL + C). On peut alors utiliser cette liste dans une s\u00e9lection par expression dans QGIS, avec par exemple l'expression 1 2 3 4 5 6 \"id_parcelle\" IN ( 729091 , 742330 , 742783 , 742513 , 742514 , 743114 , 742992 , 742578 , 742991 , 742544 , 743009 , 744282 , 744378 , 744378 , 744281 , 744199 , 743646 , 746445 , 743680 , 744280 , 743653 , 743812 , 743208 , 743812 , 743813 , 744199 , 694298 , 694163 , 721712 , 707463 , 744412 , 707907 , 707069 , 721715 , 721715 , 696325 , 696372 , 746305 , 722156 , 722555 , 722195 , 714500 , 715969 , 722146 , 722287 , 723526 , 720296 , 720296 , 722296 , 723576 , 723572 , 723572 , 723571 , 724056 , 723570 , 723568 , 740376 , 722186 , 724055 , 714706 , 723413 , 723988 , 721808 , 721808 , 723413 , 724064 , 723854 , 723854 , 724063 , 723518 , 720736 , 720653 , 741079 , 741227 , 740932 , 740932 , 740891 , 721259 , 741304 , 741304 , 741501 , 741226 , 741812 ) Une fois les parcelles s\u00e9lectionn\u00e9es, on peut utiliser certains outils de QGIS pour faciliter la correction: plugin V\u00e9rifier les g\u00e9om\u00e9tries en cochant la case Uniquement les entit\u00e9s s\u00e9lectionn\u00e9es plugin Accrochage de g\u00e9om\u00e9trie plugin Go 2 next feature pour facilement zoomer d'objets en objets Accrocher les g\u00e9om\u00e9tries sur d'autres g\u00e9om\u00e9tries # Dans PostGIS, on peut utiliser la fonction ST_Snap dans une requ\u00eate SQL pour d\u00e9placer les noeuds d'une g\u00e9om\u00e9trie et les coller sur ceux d'une autre. Par exemple, coller les g\u00e9om\u00e9tries choisies (via identifiants dans le WHERE) de la table de zonage sur les parcelles choisies (via identifiants dans le WHERE): 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 WITH a AS ( SELECT DISTINCT z . id_zone_urba , st_force2d ( ST_Multi ( ST_Snap ( ST_Simplify ( z . geom , 1 ), ST_Collect ( p . geom ), 0 . 5 ) ) ) AS geom FROM z_formation . parcelle_havre AS p INNER JOIN z_formation . zone_urba AS z ON st_dwithin ( z . geom , p . geom , 0 . 5 ) WHERE TRUE AND z . id_zone_urba IN ( 113 , 29 ) AND p . id_parcelle IN ( 711337 , 711339 , 711240 , 711343 ) GROUP BY z . id_zone_urba ) UPDATE z_formation . zone_urba pz SET geom = a . geom FROM a WHERE pz . id_zone_urba = a . id_zone_urba Attention: Cette fonction ne sait coller qu' aux noeuds de la table de r\u00e9f\u00e9rence, pas aux segments. Il serait n\u00e9anmoins possible de cr\u00e9er automatiquement les noeuds situ\u00e9s sur la projection du noeud \u00e0 d\u00e9placer sur la g\u00e9om\u00e9trie de r\u00e9f\u00e9rence. Dans la pratique, il est tr\u00e8s souvent fastidieux de corriger les erreurs de topologie d'une couche. Les outils automatiques ( V\u00e9rifier les g\u00e9om\u00e9tries de QGIS ou outil v.clean de Grass) ne permettent pas toujours de bien voir ce qui a \u00e9t\u00e9 modifi\u00e9. Au contraire, une modification manuelle est plus pr\u00e9cise, mais prend beaucoup de temps. Le Minist\u00e8re du D\u00e9veloppement Durable a mis en ligne un document int\u00e9ressant sur les outils disponibles dans QGIS, OpenJump et PostgreSQL pour valider et corriger les g\u00e9om\u00e9tries: http://www.geoinformations.developpement-durable.gouv.fr/verification-et-corrections-des-geometries-a3522.html","title":"Topologie"},{"location":"check_topology/#verifier-la-topologie","text":"","title":"V\u00e9rifier la topologie"},{"location":"check_topology/#deplacer-les-noeuds-sur-une-grille","text":"Avant de v\u00e9rifier la topologie, il faut au pr\u00e9alable avoir des g\u00e9om\u00e9tries valides (cf. chapitre pr\u00e9c\u00e9dent). Certaines micro-erreurs de topologie peuvent peuvent \u00eatre corrig\u00e9es en r\u00e9alisant une simplification des donn\u00e9es \u00e0 l'aide d'une grille, par exemple pour corriger des soucis d'arrondis. Pour cela, PostGIS a une fonction ST_SnapToGrid . On peut utiliser conjointement ST_Simplify et ST_SnapToGrid pour effectuer une premi\u00e8re correction sur les donn\u00e9es. Attention, ces fonctions modifient la donn\u00e9e. A vous de choisir la bonne tol\u00e9rance, par exemple 5 cm, qui d\u00e9pend de votre donn\u00e9e et de votre cas d'utilisation. Tester la simplification en lan\u00e7ant la requ\u00eate suivante, et en chargeant le r\u00e9sultat comme une nouvelle couche dans QGIS 1 2 3 4 5 6 7 8 9 10 11 12 13 14 SELECT ST_Multi ( ST_CollectionExtract ( ST_MakeValid ( ST_SnapToGrid ( st_simplify ( geom , 0 ), 0 . 05 -- 5 cm ) ), 3 ) ):: geometry ( multipolygon , 2154 ) FROM z_formation . parcelle_havre ; Une fois le r\u00e9sultat visuellement test\u00e9 dans QGIS, par comparaison avec la table source, on peut choisir de modifier la g\u00e9om\u00e9trie de la table avec la version simplifi\u00e9e des donn\u00e9es: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 -- Parcelles UPDATE z_formation . parcelle_havre SET geom = ST_Multi ( ST_CollectionExtract ( ST_MakeValid ( ST_SnapToGrid ( st_simplify ( geom , 0 ), 0 . 05 -- 5 cm ) ), 3 ) ) ; ; Attention: Si vous avez d'autres tables avec des objets en relation spatiale avec cette table, il faut aussi effectuer le m\u00eame traitement pour que les g\u00e9om\u00e9tries de toutes les couches se calent sur la m\u00eame grille. Par exemple la table des zonages. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 UPDATE z_formation . zone_urba SET geom = ST_Multi ( ST_CollectionExtract ( ST_MakeValid ( ST_SnapToGrid ( st_simplify ( geom , 0 ), 0 . 05 -- 5 cm ) ), 3 ) ) ;","title":"D\u00e9placer les noeuds sur une grille"},{"location":"check_topology/#reperer-certaines-erreurs-de-topologies","text":"PostGIS poss\u00e8de de nombreuses fonctions de relations spatiales qui permettent de trouver les objets qui se chevauchent, qui se touchent, etc. Ces fonctions peuvent \u00eatre utilis\u00e9es pour comparer les objets d'une m\u00eame table, ou de deux tables diff\u00e9rentes. Voir: https://postgis.net/docs/reference.html#Spatial_Relationships_Measurements Par exemple, trouver les parcelles voisines qui se recouvrent: on utilise la fonction ST_Overlaps . On peut cr\u00e9er une couche listant les recouvrements: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 DROP TABLE IF EXISTS z_formation . recouvrement_parcelle_voisines ; CREATE TABLE z_formation . recouvrement_parcelle_voisines AS SELECT DISTINCT ON ( geom ) parcelle_a , parcelle_b , aire_a , aire_b , ST_Area ( geom ) AS aire , geom FROM ( SELECT a . id_parcelle AS parcelle_a , ST_Area ( a . geom ) AS aire_a , b . id_parcelle AS parcelle_b , ST_Area ( b . geom ) AS aire_b , ( ST_Multi ( st_collectionextract ( ST_MakeValid ( ST_Intersection ( a . geom , b . geom )) , 3 ) )):: geometry ( MultiPolygon , 2154 ) AS geom FROM z_formation . parcelle_havre AS a JOIN z_formation . parcelle_havre AS b ON a . id_parcelle != b . id_parcelle --ON ST_Intersects(a.geom, b.geom) AND ST_Overlaps ( a . geom , b . geom ) ) AS voisin ORDER BY geom ; CREATE INDEX ON z_formation . recouvrement_parcelle_voisines USING GIST ( geom ); On peut alors ouvrir cette couche dans QGIS pour zoomer sur chaque objet de recouvrement. R\u00e9cup\u00e9rer la liste des identifiants de ces parcelles: 1 SELECT string_agg ( parcelle_a :: text , ',' ) FROM z_formation . recouvrement_parcelle_voisines ; On peut utiliser le r\u00e9sultat de cette requ\u00eate pour s\u00e9lectionner les parcelles probl\u00e9matiques: on s\u00e9lectionne le r\u00e9sultat dans le tableau du gestionnaire de base de donn\u00e9es, et on copie (CTRL + C). On peut alors utiliser cette liste dans une s\u00e9lection par expression dans QGIS, avec par exemple l'expression 1 2 3 4 5 6 \"id_parcelle\" IN ( 729091 , 742330 , 742783 , 742513 , 742514 , 743114 , 742992 , 742578 , 742991 , 742544 , 743009 , 744282 , 744378 , 744378 , 744281 , 744199 , 743646 , 746445 , 743680 , 744280 , 743653 , 743812 , 743208 , 743812 , 743813 , 744199 , 694298 , 694163 , 721712 , 707463 , 744412 , 707907 , 707069 , 721715 , 721715 , 696325 , 696372 , 746305 , 722156 , 722555 , 722195 , 714500 , 715969 , 722146 , 722287 , 723526 , 720296 , 720296 , 722296 , 723576 , 723572 , 723572 , 723571 , 724056 , 723570 , 723568 , 740376 , 722186 , 724055 , 714706 , 723413 , 723988 , 721808 , 721808 , 723413 , 724064 , 723854 , 723854 , 724063 , 723518 , 720736 , 720653 , 741079 , 741227 , 740932 , 740932 , 740891 , 721259 , 741304 , 741304 , 741501 , 741226 , 741812 ) Une fois les parcelles s\u00e9lectionn\u00e9es, on peut utiliser certains outils de QGIS pour faciliter la correction: plugin V\u00e9rifier les g\u00e9om\u00e9tries en cochant la case Uniquement les entit\u00e9s s\u00e9lectionn\u00e9es plugin Accrochage de g\u00e9om\u00e9trie plugin Go 2 next feature pour facilement zoomer d'objets en objets","title":"Rep\u00e9rer certaines erreurs de topologies"},{"location":"check_topology/#accrocher-les-geometries-sur-dautres-geometries","text":"Dans PostGIS, on peut utiliser la fonction ST_Snap dans une requ\u00eate SQL pour d\u00e9placer les noeuds d'une g\u00e9om\u00e9trie et les coller sur ceux d'une autre. Par exemple, coller les g\u00e9om\u00e9tries choisies (via identifiants dans le WHERE) de la table de zonage sur les parcelles choisies (via identifiants dans le WHERE): 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 WITH a AS ( SELECT DISTINCT z . id_zone_urba , st_force2d ( ST_Multi ( ST_Snap ( ST_Simplify ( z . geom , 1 ), ST_Collect ( p . geom ), 0 . 5 ) ) ) AS geom FROM z_formation . parcelle_havre AS p INNER JOIN z_formation . zone_urba AS z ON st_dwithin ( z . geom , p . geom , 0 . 5 ) WHERE TRUE AND z . id_zone_urba IN ( 113 , 29 ) AND p . id_parcelle IN ( 711337 , 711339 , 711240 , 711343 ) GROUP BY z . id_zone_urba ) UPDATE z_formation . zone_urba pz SET geom = a . geom FROM a WHERE pz . id_zone_urba = a . id_zone_urba Attention: Cette fonction ne sait coller qu' aux noeuds de la table de r\u00e9f\u00e9rence, pas aux segments. Il serait n\u00e9anmoins possible de cr\u00e9er automatiquement les noeuds situ\u00e9s sur la projection du noeud \u00e0 d\u00e9placer sur la g\u00e9om\u00e9trie de r\u00e9f\u00e9rence. Dans la pratique, il est tr\u00e8s souvent fastidieux de corriger les erreurs de topologie d'une couche. Les outils automatiques ( V\u00e9rifier les g\u00e9om\u00e9tries de QGIS ou outil v.clean de Grass) ne permettent pas toujours de bien voir ce qui a \u00e9t\u00e9 modifi\u00e9. Au contraire, une modification manuelle est plus pr\u00e9cise, mais prend beaucoup de temps. Le Minist\u00e8re du D\u00e9veloppement Durable a mis en ligne un document int\u00e9ressant sur les outils disponibles dans QGIS, OpenJump et PostgreSQL pour valider et corriger les g\u00e9om\u00e9tries: http://www.geoinformations.developpement-durable.gouv.fr/verification-et-corrections-des-geometries-a3522.html","title":"Accrocher les g\u00e9om\u00e9tries sur d'autres g\u00e9om\u00e9tries"},{"location":"fdw/","text":"Acc\u00e9der \u00e0 des donn\u00e9es externes : les Foreign Data Wrapper (FDW) # L'utilisation d'un FDW permet de consulter des donn\u00e9es externes \u00e0 la base comme si elles \u00e9taient stock\u00e9es dans des tables. On peut lancer des requ\u00eates pour r\u00e9cup\u00e9rer seulement certains champs, filtrer les donn\u00e9es, etc. Des tables \u00e9trang\u00e8res sont cr\u00e9\u00e9es, qui pointent vers les donn\u00e9es externes. A chaque requ\u00eate sur ces tables, PostgreSQL r\u00e9cup\u00e8re les donn\u00e9es depuis la connexion au serveur externe. On passe classiquement par les \u00e9tapes suivantes: Ajout de l' extension correspondant au format souhait\u00e9: postgres_fdw (bases PostgreSQL externes), ogr_fdw (donn\u00e9es vectorielles via ogr2ogr), etc. Cr\u00e9ation d'un serveur qui permet de configurer les informations de connexion au serveur externe Cr\u00e9ation optionnelle d'un sch\u00e9ma pour y stocker les tables de ce serveur Cr\u00e9ation manuelle ou automatique de tables \u00e9trang\u00e8res qui pointent vers les donn\u00e9es externes Requ\u00eates sur ces tables \u00e9trang\u00e8res Le FDW ogr_fdw pour lire des donn\u00e9es vectorielles # Avec ce Foreign Data Wrapper ogr_fdw , on peut appeler n'importe quelle source de donn\u00e9es externe compatible avec la librairie ogr2ogr et les exploiter comme des tables: fichiers GeoJSON ou Shapefile, GPX, CSV, mais aussi les protocoles comme le WFS. Voir la documentation officielle de ogr_fdw . Installation # Pour l'installer sur une machine Linux , il suffit d'installer le paquet correspondant \u00e0 la version de PostgreSQL, par exemple postgresql-11-ogr-fdw . Sous Windows , il est disponible avec le paquet PostGIS via l'outil StackBuilder . Exemple d'utilisation: r\u00e9cup\u00e9rer des couches d'un serveur WFS # Nous allons utiliser le FDW pour r\u00e9cup\u00e9rer des donn\u00e9es mises \u00e0 disposition sur le serveur de l'INPN via le protocole WFS. Vous pouvez d'abord tester dans QGIS quelles donn\u00e9es sont disponibles sur ce serveur en cr\u00e9ant une nouvelle connexion WFS avec l'URL http://ws.carmencarto.fr/WFS/119/fxx_inpn? Via QGIS ou un autre client \u00e0 la base de donn\u00e9es, nous pouvons maintenant montrer comment r\u00e9cuperer ces donn\u00e9es: Ajouter l' extension ogr_fdw : 1 2 3 -- Ajouter l'extension pour lire des fichiers SIG -- Cette commande doit \u00eatre lanc\u00e9e par un super utilisateur (ou un utilisateur ayant le droit de le faire) CREATE EXTENSION IF NOT EXISTS ogr_fdw ; Cr\u00e9er le serveur de donn\u00e9es: 1 2 3 4 5 6 7 -- Cr\u00e9er le serveur DROP SERVER IF EXISTS fdw_ogr_inpn_metropole ; CREATE SERVER fdw_ogr_inpn_metropole FOREIGN DATA WRAPPER ogr_fdw OPTIONS ( datasource 'WFS:http://ws.carmencarto.fr/WFS/119/fxx_inpn?' , format 'WFS' ); Cr\u00e9er un sch\u00e9ma pour y stocker les tables \u00e9trang\u00e8res: 1 2 -- Cr\u00e9er un sch\u00e9ma pour la dreal CREATE SCHEMA IF NOT EXISTS inpn_metropole ; Cr\u00e9er automatiquement les tables \u00e9trang\u00e8res qui \"pointent\" vers les couches du WFS, via la commande IMPORT SCHEMA : 1 2 3 4 5 6 7 8 9 10 11 -- R\u00e9cup\u00e9rer l'ensemble des couches WFS comme des tables dans le sch\u00e9ma ref_dreal IMPORT FOREIGN SCHEMA ogr_all FROM SERVER fdw_ogr_inpn_metropole INTO inpn_metropole OPTIONS ( -- mettre le nom des tables en minuscule et sans caract\u00e8res bizares launder_table_names 'true' , -- mettre le nom des champs en minuscule launder_column_names 'true' ) ; Lister les tables r\u00e9cup\u00e9r\u00e9es 1 2 3 4 SELECT foreign_table_schema , foreign_table_name FROM information_schema . foreign_tables WHERE foreign_table_schema = 'inpn_metropole' ORDER BY foreign_table_schema , foreign_table_name ; ce qui montre: foreign_table_schema foreign_table_name inpn_metropole arretes_de_protection_de_biotope inpn_metropole arretes_de_protection_de_geotope inpn_metropole bien_du_patrimoine_mondial_de_l_unesco inpn_metropole geoparcs inpn_metropole ospar inpn_metropole parc_naturel_marin inpn_metropole parcs_nationaux inpn_metropole parcs_naturels_regionaux inpn_metropole reserves_biologiques inpn_metropole reserves_de_la_biosphere inpn_metropole reserves_integrales_de_parcs_nationaux inpn_metropole reserves_nationales_de_chasse_et_faune_sauvage inpn_metropole reserves_naturelles_nationales inpn_metropole reserves_naturelles_regionales inpn_metropole rnc inpn_metropole sites_d_importance_communautaire inpn_metropole sites_d_importance_communautaire_joue__zsc_sic_ inpn_metropole sites_ramsar inpn_metropole terrains_des_conservatoires_des_espaces_naturels inpn_metropole terrains_du_conservatoire_du_littoral inpn_metropole zico inpn_metropole znieff1 inpn_metropole znieff1_mer inpn_metropole znieff2 inpn_metropole znieff2_mer inpn_metropole zones_de_protection_speciale Lire les donn\u00e9es des couches WFS via une simple requ\u00eate sur les tables \u00e9trang\u00e8res: 1 2 3 4 -- Tester SELECT * FROM inpn_metropole . zico LIMIT 1 ; Attention , lorsqu'on acc\u00e8de depuis PostgreSQL \u00e0 un serveur WFS, on est tributaire des performances de ce serveur, et du temps de transfert des donn\u00e9es vers la base. Nous d\u00e9conseillons fortement dans ce cas de charger le serveur externe en r\u00e9alisant des requ\u00eates complexes (ou trop fr\u00e9quentes) sur ces tables \u00e9trang\u00e8res, surtout lorsque les donn\u00e9es \u00e9voluent peu. Au contraire, nous conseillons de cr\u00e9er des vues mat\u00e9rialis\u00e9es \u00e0 partir des tables \u00e9trang\u00e8res pour \u00e9viter des requ\u00eates lourdes en stockant les donn\u00e9es dans la base: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 -- Pour \u00e9viter de requ\u00eater \u00e0 chaque fois le WFS, on peut cr\u00e9er des vues mat\u00e9rialis\u00e9es -- suppression de la vue si elle existe d\u00e9j\u00e0 DROP MATERIALIZED VIEW IF EXISTS inpn_metropole . vm_zico ; -- cr\u00e9ation de la vue: on doit parfois forcer le type de g\u00e9om\u00e9trie attendue CREATE MATERIALIZED VIEW inpn_metropole . vm_zico AS SELECT * , ( ST_multi ( msgeometry )):: geometry ( multipolygon , 2154 ) AS geom FROM inpn_metropole . zico ; -- Ajout d'un index spatial sur la g\u00e9om\u00e9trie CREATE INDEX ON inpn_metropole . vm_zico USING GIST ( geom ); Une fois la vue cr\u00e9\u00e9e, vous pouvez faire vos requ\u00eates sur cette vue, avec des performances bien meilleures et un all\u00e8gement de la charge sur le serveur externe. Pour rafra\u00eechir les donn\u00e9es \u00e0 partir du serveur WFS, il suffit de rafra\u00eechir la ou les vues mat\u00e9rialis\u00e9es: 1 2 -- Rafra\u00eechir la vue, par exemple \u00e0 lancer une fois par mois REFRESH MATERIALIZED VIEW inpn_metropole . vm_zico ; Le FDW postgres_fdw pour acc\u00e9der aux tables d'une autre base de donn\u00e9es PostgreSQL # 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 -- Cr\u00e9ation du serveur externe DROP SERVER IF EXISTS foreign_server_test CASCADE ; CREATE SERVER IF NOT EXISTS foreign_server_test FOREIGN DATA WRAPPER postgres_fdw OPTIONS ( host 'mon_serveur_postgresql_externe.com' , port '5432' , dbname 'external_database' ) ; -- on d\u00e9clare se connecter en tant qu'utilisateur mon_utilisateur externe lorsqu'on r\u00e9cup\u00e8re des donn\u00e9es CREATE USER MAPPING FOR \"\" SERVER foreign_server_test OPTIONS ( user 'mon_utilisateur' , password '***********' ); -- on stocke les tables \u00e9trang\u00e8res dans un sch\u00e9ma sp\u00e9cifique pour isoler des autres sch\u00e9mas en dur DROP SCHEMA IF EXISTS fdw_test_schema CASCADE ; CREATE SCHEMA IF NOT EXISTS fdw_test_schema ; -- importer automatiquement les tables d'un sch\u00e9ma de la base distante IMPORT FOREIGN SCHEMA \"un_schema\" LIMIT TO ( \"une_table\" , \"une_autre_table\" ) FROM SERVER foreign_server_test INTO fdw_test_schema ; -- Tester SELECT * FROM fdw_test_schema . une_table LIMIT 1 ; Continuer vers Tutoriels en ligne","title":"Donn\u00e9es externes"},{"location":"fdw/#acceder-a-des-donnees-externes-les-foreign-data-wrapper-fdw","text":"L'utilisation d'un FDW permet de consulter des donn\u00e9es externes \u00e0 la base comme si elles \u00e9taient stock\u00e9es dans des tables. On peut lancer des requ\u00eates pour r\u00e9cup\u00e9rer seulement certains champs, filtrer les donn\u00e9es, etc. Des tables \u00e9trang\u00e8res sont cr\u00e9\u00e9es, qui pointent vers les donn\u00e9es externes. A chaque requ\u00eate sur ces tables, PostgreSQL r\u00e9cup\u00e8re les donn\u00e9es depuis la connexion au serveur externe. On passe classiquement par les \u00e9tapes suivantes: Ajout de l' extension correspondant au format souhait\u00e9: postgres_fdw (bases PostgreSQL externes), ogr_fdw (donn\u00e9es vectorielles via ogr2ogr), etc. Cr\u00e9ation d'un serveur qui permet de configurer les informations de connexion au serveur externe Cr\u00e9ation optionnelle d'un sch\u00e9ma pour y stocker les tables de ce serveur Cr\u00e9ation manuelle ou automatique de tables \u00e9trang\u00e8res qui pointent vers les donn\u00e9es externes Requ\u00eates sur ces tables \u00e9trang\u00e8res","title":"Acc\u00e9der \u00e0 des donn\u00e9es externes : les Foreign Data Wrapper (FDW)"},{"location":"fdw/#le-fdw-ogr_fdw-pour-lire-des-donnees-vectorielles","text":"Avec ce Foreign Data Wrapper ogr_fdw , on peut appeler n'importe quelle source de donn\u00e9es externe compatible avec la librairie ogr2ogr et les exploiter comme des tables: fichiers GeoJSON ou Shapefile, GPX, CSV, mais aussi les protocoles comme le WFS. Voir la documentation officielle de ogr_fdw .","title":"Le FDW ogr_fdw pour lire des donn\u00e9es vectorielles"},{"location":"fdw/#installation","text":"Pour l'installer sur une machine Linux , il suffit d'installer le paquet correspondant \u00e0 la version de PostgreSQL, par exemple postgresql-11-ogr-fdw . Sous Windows , il est disponible avec le paquet PostGIS via l'outil StackBuilder .","title":"Installation"},{"location":"fdw/#exemple-dutilisation-recuperer-des-couches-dun-serveur-wfs","text":"Nous allons utiliser le FDW pour r\u00e9cup\u00e9rer des donn\u00e9es mises \u00e0 disposition sur le serveur de l'INPN via le protocole WFS. Vous pouvez d'abord tester dans QGIS quelles donn\u00e9es sont disponibles sur ce serveur en cr\u00e9ant une nouvelle connexion WFS avec l'URL http://ws.carmencarto.fr/WFS/119/fxx_inpn? Via QGIS ou un autre client \u00e0 la base de donn\u00e9es, nous pouvons maintenant montrer comment r\u00e9cuperer ces donn\u00e9es: Ajouter l' extension ogr_fdw : 1 2 3 -- Ajouter l'extension pour lire des fichiers SIG -- Cette commande doit \u00eatre lanc\u00e9e par un super utilisateur (ou un utilisateur ayant le droit de le faire) CREATE EXTENSION IF NOT EXISTS ogr_fdw ; Cr\u00e9er le serveur de donn\u00e9es: 1 2 3 4 5 6 7 -- Cr\u00e9er le serveur DROP SERVER IF EXISTS fdw_ogr_inpn_metropole ; CREATE SERVER fdw_ogr_inpn_metropole FOREIGN DATA WRAPPER ogr_fdw OPTIONS ( datasource 'WFS:http://ws.carmencarto.fr/WFS/119/fxx_inpn?' , format 'WFS' ); Cr\u00e9er un sch\u00e9ma pour y stocker les tables \u00e9trang\u00e8res: 1 2 -- Cr\u00e9er un sch\u00e9ma pour la dreal CREATE SCHEMA IF NOT EXISTS inpn_metropole ; Cr\u00e9er automatiquement les tables \u00e9trang\u00e8res qui \"pointent\" vers les couches du WFS, via la commande IMPORT SCHEMA : 1 2 3 4 5 6 7 8 9 10 11 -- R\u00e9cup\u00e9rer l'ensemble des couches WFS comme des tables dans le sch\u00e9ma ref_dreal IMPORT FOREIGN SCHEMA ogr_all FROM SERVER fdw_ogr_inpn_metropole INTO inpn_metropole OPTIONS ( -- mettre le nom des tables en minuscule et sans caract\u00e8res bizares launder_table_names 'true' , -- mettre le nom des champs en minuscule launder_column_names 'true' ) ; Lister les tables r\u00e9cup\u00e9r\u00e9es 1 2 3 4 SELECT foreign_table_schema , foreign_table_name FROM information_schema . foreign_tables WHERE foreign_table_schema = 'inpn_metropole' ORDER BY foreign_table_schema , foreign_table_name ; ce qui montre: foreign_table_schema foreign_table_name inpn_metropole arretes_de_protection_de_biotope inpn_metropole arretes_de_protection_de_geotope inpn_metropole bien_du_patrimoine_mondial_de_l_unesco inpn_metropole geoparcs inpn_metropole ospar inpn_metropole parc_naturel_marin inpn_metropole parcs_nationaux inpn_metropole parcs_naturels_regionaux inpn_metropole reserves_biologiques inpn_metropole reserves_de_la_biosphere inpn_metropole reserves_integrales_de_parcs_nationaux inpn_metropole reserves_nationales_de_chasse_et_faune_sauvage inpn_metropole reserves_naturelles_nationales inpn_metropole reserves_naturelles_regionales inpn_metropole rnc inpn_metropole sites_d_importance_communautaire inpn_metropole sites_d_importance_communautaire_joue__zsc_sic_ inpn_metropole sites_ramsar inpn_metropole terrains_des_conservatoires_des_espaces_naturels inpn_metropole terrains_du_conservatoire_du_littoral inpn_metropole zico inpn_metropole znieff1 inpn_metropole znieff1_mer inpn_metropole znieff2 inpn_metropole znieff2_mer inpn_metropole zones_de_protection_speciale Lire les donn\u00e9es des couches WFS via une simple requ\u00eate sur les tables \u00e9trang\u00e8res: 1 2 3 4 -- Tester SELECT * FROM inpn_metropole . zico LIMIT 1 ; Attention , lorsqu'on acc\u00e8de depuis PostgreSQL \u00e0 un serveur WFS, on est tributaire des performances de ce serveur, et du temps de transfert des donn\u00e9es vers la base. Nous d\u00e9conseillons fortement dans ce cas de charger le serveur externe en r\u00e9alisant des requ\u00eates complexes (ou trop fr\u00e9quentes) sur ces tables \u00e9trang\u00e8res, surtout lorsque les donn\u00e9es \u00e9voluent peu. Au contraire, nous conseillons de cr\u00e9er des vues mat\u00e9rialis\u00e9es \u00e0 partir des tables \u00e9trang\u00e8res pour \u00e9viter des requ\u00eates lourdes en stockant les donn\u00e9es dans la base: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 -- Pour \u00e9viter de requ\u00eater \u00e0 chaque fois le WFS, on peut cr\u00e9er des vues mat\u00e9rialis\u00e9es -- suppression de la vue si elle existe d\u00e9j\u00e0 DROP MATERIALIZED VIEW IF EXISTS inpn_metropole . vm_zico ; -- cr\u00e9ation de la vue: on doit parfois forcer le type de g\u00e9om\u00e9trie attendue CREATE MATERIALIZED VIEW inpn_metropole . vm_zico AS SELECT * , ( ST_multi ( msgeometry )):: geometry ( multipolygon , 2154 ) AS geom FROM inpn_metropole . zico ; -- Ajout d'un index spatial sur la g\u00e9om\u00e9trie CREATE INDEX ON inpn_metropole . vm_zico USING GIST ( geom ); Une fois la vue cr\u00e9\u00e9e, vous pouvez faire vos requ\u00eates sur cette vue, avec des performances bien meilleures et un all\u00e8gement de la charge sur le serveur externe. Pour rafra\u00eechir les donn\u00e9es \u00e0 partir du serveur WFS, il suffit de rafra\u00eechir la ou les vues mat\u00e9rialis\u00e9es: 1 2 -- Rafra\u00eechir la vue, par exemple \u00e0 lancer une fois par mois REFRESH MATERIALIZED VIEW inpn_metropole . vm_zico ;","title":"Exemple d'utilisation: r\u00e9cup\u00e9rer des couches d'un serveur WFS"},{"location":"fdw/#le-fdw-postgres_fdw-pour-acceder-aux-tables-dune-autre-base-de-donnees-postgresql","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 -- Cr\u00e9ation du serveur externe DROP SERVER IF EXISTS foreign_server_test CASCADE ; CREATE SERVER IF NOT EXISTS foreign_server_test FOREIGN DATA WRAPPER postgres_fdw OPTIONS ( host 'mon_serveur_postgresql_externe.com' , port '5432' , dbname 'external_database' ) ; -- on d\u00e9clare se connecter en tant qu'utilisateur mon_utilisateur externe lorsqu'on r\u00e9cup\u00e8re des donn\u00e9es CREATE USER MAPPING FOR \"\" SERVER foreign_server_test OPTIONS ( user 'mon_utilisateur' , password '***********' ); -- on stocke les tables \u00e9trang\u00e8res dans un sch\u00e9ma sp\u00e9cifique pour isoler des autres sch\u00e9mas en dur DROP SCHEMA IF EXISTS fdw_test_schema CASCADE ; CREATE SCHEMA IF NOT EXISTS fdw_test_schema ; -- importer automatiquement les tables d'un sch\u00e9ma de la base distante IMPORT FOREIGN SCHEMA \"un_schema\" LIMIT TO ( \"une_table\" , \"une_autre_table\" ) FROM SERVER foreign_server_test INTO fdw_test_schema ; -- Tester SELECT * FROM fdw_test_schema . une_table LIMIT 1 ; Continuer vers Tutoriels en ligne","title":"Le FDW postgres_fdw pour acc\u00e9der aux tables d'une autre base de donn\u00e9es PostgreSQL"},{"location":"filter_data/","text":"Filtrer les donn\u00e9es : la clause WHERE # R\u00e9cup\u00e9rer les donn\u00e9es \u00e0 partir de la valeur exacte d'un champ . Ici le nom de la commune 1 2 3 4 5 -- R\u00e9cup\u00e9rer seulement la commune du Havre SELECT id_commune , code_insee , nom , population FROM z_formation . commune WHERE nom = 'Le Havre' On peut chercher les lignes dont le champ correspondant \u00e0 plusieurs valeurs 1 2 3 4 5 -- R\u00e9cup\u00e9rer la commune du Havre et de Rouen SELECT id_commune , code_insee , nom , population FROM z_formation . commune WHERE nom IN ( 'Le Havre' , 'Rouen' ) On peut aussi filtrer sur des champs de type entier ou nombres r\u00e9els , et faire des conditions comme des in\u00e9galit\u00e9s. 1 2 3 4 5 6 7 -- Filtrer les donn\u00e9es, par exemple par d\u00e9partement et population SELECT * FROM z_formation . commune WHERE True AND depart = 'SEINE-MARITIME' AND population > 1000 ; On peut chercher des lignes dont un champ commence et/ou se termine par un texte 1 2 3 4 5 6 7 8 9 10 -- Filtrer les donn\u00e9es, par exemple par d\u00e9partement et d\u00e9but et/ou fin de nom SELECT * FROM z_formation . commune WHERE True AND depart = 'SEINE-MARITIME' -- commence par C AND nom LIKE 'C%' -- se termine par ville AND nom ILIKE '%ville' ; On peut utiliser les calculs sur les g\u00e9om\u00e9tries pour filtrer les donn\u00e9es. Par exemple filtrer par longueur de lignes 1 2 3 4 5 6 -- Les routes qui font plus que 10km -- on peut utiliser des fonctions dans la clause WHERE SELECT id_route , id , geom FROM z_formation . route WHERE True AND ST_Length ( geom ) > 10000 Continuer vers Regrouper des donn\u00e9es: GROUP BY Quiz # \u00c9crire une requ\u00eate retournant toutes les communes de Seine-Maritime qui contiennent la chaine de caract\u00e8res 'saint' 1 2 3 4 5 6 -- Toutes les communes de Seine-Maritime qui contiennent le mot saint SELECT * FROM z_formation . commune WHERE True AND depart = 'SEINE-MARITIME' AND nom ILIKE '%saint%' ; \u00c9crire une requ\u00eate retournant les nom et centro\u00efde des communes de Seine-Maritime avec une population inf\u00e9rieure ou \u00e9gale \u00e0 50 1 2 3 4 5 6 -- Nom et centro\u00efde des communes de Seinte-Maritime avec une population <= 50 SELECT nom , ST_Centroid ( geom ) as geom FROM z_formation . commune WHERE True AND depart = 'SEINE-MARITIME' AND population <= 50","title":"Filtrer"},{"location":"filter_data/#filtrer-les-donnees-la-clause-where","text":"R\u00e9cup\u00e9rer les donn\u00e9es \u00e0 partir de la valeur exacte d'un champ . Ici le nom de la commune 1 2 3 4 5 -- R\u00e9cup\u00e9rer seulement la commune du Havre SELECT id_commune , code_insee , nom , population FROM z_formation . commune WHERE nom = 'Le Havre' On peut chercher les lignes dont le champ correspondant \u00e0 plusieurs valeurs 1 2 3 4 5 -- R\u00e9cup\u00e9rer la commune du Havre et de Rouen SELECT id_commune , code_insee , nom , population FROM z_formation . commune WHERE nom IN ( 'Le Havre' , 'Rouen' ) On peut aussi filtrer sur des champs de type entier ou nombres r\u00e9els , et faire des conditions comme des in\u00e9galit\u00e9s. 1 2 3 4 5 6 7 -- Filtrer les donn\u00e9es, par exemple par d\u00e9partement et population SELECT * FROM z_formation . commune WHERE True AND depart = 'SEINE-MARITIME' AND population > 1000 ; On peut chercher des lignes dont un champ commence et/ou se termine par un texte 1 2 3 4 5 6 7 8 9 10 -- Filtrer les donn\u00e9es, par exemple par d\u00e9partement et d\u00e9but et/ou fin de nom SELECT * FROM z_formation . commune WHERE True AND depart = 'SEINE-MARITIME' -- commence par C AND nom LIKE 'C%' -- se termine par ville AND nom ILIKE '%ville' ; On peut utiliser les calculs sur les g\u00e9om\u00e9tries pour filtrer les donn\u00e9es. Par exemple filtrer par longueur de lignes 1 2 3 4 5 6 -- Les routes qui font plus que 10km -- on peut utiliser des fonctions dans la clause WHERE SELECT id_route , id , geom FROM z_formation . route WHERE True AND ST_Length ( geom ) > 10000 Continuer vers Regrouper des donn\u00e9es: GROUP BY","title":"Filtrer les donn\u00e9es : la clause WHERE"},{"location":"filter_data/#quiz","text":"\u00c9crire une requ\u00eate retournant toutes les communes de Seine-Maritime qui contiennent la chaine de caract\u00e8res 'saint' 1 2 3 4 5 6 -- Toutes les communes de Seine-Maritime qui contiennent le mot saint SELECT * FROM z_formation . commune WHERE True AND depart = 'SEINE-MARITIME' AND nom ILIKE '%saint%' ; \u00c9crire une requ\u00eate retournant les nom et centro\u00efde des communes de Seine-Maritime avec une population inf\u00e9rieure ou \u00e9gale \u00e0 50 1 2 3 4 5 6 -- Nom et centro\u00efde des communes de Seinte-Maritime avec une population <= 50 SELECT nom , ST_Centroid ( geom ) as geom FROM z_formation . commune WHERE True AND depart = 'SEINE-MARITIME' AND population <= 50","title":"Quiz"},{"location":"grant/","text":"Gestion des droits # Dans PostgreSQL, on peut cr\u00e9er des roles (des utilisateurs) et g\u00e9rer les droits sur les diff\u00e9rents objets: base, sch\u00e9mas, tables, fonctions, etc. La documentation officielle de PostgreSQL est compl\u00e8te, et propose plusieurs exemples. Nous montrons ci-dessous quelques utilisations possibles. Attention, pour pouvoir r\u00e9aliser certaines op\u00e9rations, vous devez: soit \u00eatre super-utilisateur (cr\u00e9er un r\u00f4le de connexion) soit \u00eatre propri\u00e9taire des objets pour lesquels modifier les droits Cr\u00e9ation d'un sch\u00e9ma de test et d'un r\u00f4le de connexion, en tant qu'utilisateur avec des droits forts sur la base de donn\u00e9es (cr\u00e9ation de sch\u00e9mas, de tables, etc.). 1 2 3 4 5 6 -- cr\u00e9ation d'un sch\u00e9ma de test CREATE SCHEMA IF NOT EXISTS nouveau_schema ; -- cr\u00e9ation de tables pour tester CREATE TABLE IF NOT EXISTS nouveau_schema . observation ( id serial primary key , nom text , geom geometry ( point , 2154 )); CREATE TABLE IF NOT EXISTS nouveau_schema . nomenclature ( id serial primary key , code text , libelle text ); Cr\u00e9ation d'un r\u00f4le de connexion (en tant que super-utilisateur, ou en tant qu'utilisateur ayant le droit de cr\u00e9er des r\u00f4les) 1 2 -- cr\u00e9ation d'un r\u00f4le nomm\u00e9 invite CREATE ROLE invite WITH PASSWORD 'mot_de_passe_a_changer' LOGIN ; On donne le droit de connexion sur la base (nomm\u00e9e ici qgis) 1 2 -- on donne le droit de connexion sur la base GRANT CONNECT ON DATABASE qgis TO invite ; Exemple de requ\u00eates pratiques pour donner ou retirer des droits (en tant qu'utilisateur propri\u00e9taire de la base et des objets) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 -- on donne le droit \u00e0 invite d'utiliser les sch\u00e9ma public et nouveau_schema -- Utile pour pouvoir lister les tables GRANT USAGE ON SCHEMA public , nouveau_schema TO \"invite\" ; -- on permet \u00e0 invite de lire les donn\u00e9es (SELECT) -- de toutes les tables du sch\u00e9ma nouveau_schema GRANT SELECT ON ALL TABLES IN SCHEMA nouveau_schema TO \"invite\" ; -- On permet l'ajout et la modification de donn\u00e9es sur la table observation seulement GRANT INSERT OR UPDATE ON TABLE nouveau_schema . observation TO \"invite\" ; -- On peut aussi enlever des droits avec REVOKE. -- Ex: on enl\u00e8ve la possibilit\u00e9 de faire des suppresions REVOKE DELETE ON TABLE nouveau_schema . observation FROM \"invite\" ; -- On enl\u00e8ve tous les privil\u00e8ges sur les tables du sch\u00e9ma public REVOKE ALL PRIVILEGES ON ALL TABLES IN SCHEMA public FROM \"invite\" ; -- On donne les droits de s\u00e9lection sur les tables du sch\u00e9ma public GRANT SELECT ON ALL TABLES IN SCHEMA public TO \"invite\" ; Droits par d\u00e9faut sur les nouveaux objets cr\u00e9\u00e9s 1 -- TODO Continuer vers Acc\u00e9der \u00e0 des donn\u00e9es externes: Foreign Data Wrapper","title":"Droits"},{"location":"grant/#gestion-des-droits","text":"Dans PostgreSQL, on peut cr\u00e9er des roles (des utilisateurs) et g\u00e9rer les droits sur les diff\u00e9rents objets: base, sch\u00e9mas, tables, fonctions, etc. La documentation officielle de PostgreSQL est compl\u00e8te, et propose plusieurs exemples. Nous montrons ci-dessous quelques utilisations possibles. Attention, pour pouvoir r\u00e9aliser certaines op\u00e9rations, vous devez: soit \u00eatre super-utilisateur (cr\u00e9er un r\u00f4le de connexion) soit \u00eatre propri\u00e9taire des objets pour lesquels modifier les droits Cr\u00e9ation d'un sch\u00e9ma de test et d'un r\u00f4le de connexion, en tant qu'utilisateur avec des droits forts sur la base de donn\u00e9es (cr\u00e9ation de sch\u00e9mas, de tables, etc.). 1 2 3 4 5 6 -- cr\u00e9ation d'un sch\u00e9ma de test CREATE SCHEMA IF NOT EXISTS nouveau_schema ; -- cr\u00e9ation de tables pour tester CREATE TABLE IF NOT EXISTS nouveau_schema . observation ( id serial primary key , nom text , geom geometry ( point , 2154 )); CREATE TABLE IF NOT EXISTS nouveau_schema . nomenclature ( id serial primary key , code text , libelle text ); Cr\u00e9ation d'un r\u00f4le de connexion (en tant que super-utilisateur, ou en tant qu'utilisateur ayant le droit de cr\u00e9er des r\u00f4les) 1 2 -- cr\u00e9ation d'un r\u00f4le nomm\u00e9 invite CREATE ROLE invite WITH PASSWORD 'mot_de_passe_a_changer' LOGIN ; On donne le droit de connexion sur la base (nomm\u00e9e ici qgis) 1 2 -- on donne le droit de connexion sur la base GRANT CONNECT ON DATABASE qgis TO invite ; Exemple de requ\u00eates pratiques pour donner ou retirer des droits (en tant qu'utilisateur propri\u00e9taire de la base et des objets) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 -- on donne le droit \u00e0 invite d'utiliser les sch\u00e9ma public et nouveau_schema -- Utile pour pouvoir lister les tables GRANT USAGE ON SCHEMA public , nouveau_schema TO \"invite\" ; -- on permet \u00e0 invite de lire les donn\u00e9es (SELECT) -- de toutes les tables du sch\u00e9ma nouveau_schema GRANT SELECT ON ALL TABLES IN SCHEMA nouveau_schema TO \"invite\" ; -- On permet l'ajout et la modification de donn\u00e9es sur la table observation seulement GRANT INSERT OR UPDATE ON TABLE nouveau_schema . observation TO \"invite\" ; -- On peut aussi enlever des droits avec REVOKE. -- Ex: on enl\u00e8ve la possibilit\u00e9 de faire des suppresions REVOKE DELETE ON TABLE nouveau_schema . observation FROM \"invite\" ; -- On enl\u00e8ve tous les privil\u00e8ges sur les tables du sch\u00e9ma public REVOKE ALL PRIVILEGES ON ALL TABLES IN SCHEMA public FROM \"invite\" ; -- On donne les droits de s\u00e9lection sur les tables du sch\u00e9ma public GRANT SELECT ON ALL TABLES IN SCHEMA public TO \"invite\" ; Droits par d\u00e9faut sur les nouveaux objets cr\u00e9\u00e9s 1 -- TODO Continuer vers Acc\u00e9der \u00e0 des donn\u00e9es externes: Foreign Data Wrapper","title":"Gestion des droits"},{"location":"group_data/","text":"Grouper des donn\u00e9es et calculer des statistiques # Les fonctions d'agr\u00e9gat dans PostgreSQL Valeurs distinctes d'un champ # On souhaite r\u00e9cup\u00e9rer toutes les valeurs possibles d'un champ 1 2 3 4 5 6 7 8 9 -- V\u00e9rifier les valeurs distinctes d'un champ: table commune SELECT DISTINCT depart FROM z_formation . commune ORDER BY depart -- idem sur la table lieu_dit_habite SELECT DISTINCT nature FROM z_formation . lieu_dit_habite ORDER BY nature Regrouper des donn\u00e9es en sp\u00e9cifiant les champs de regroupement # Certains calculs n\u00e9cessitent le regroupement de lignes, comme les moyennes, les sommes ou les totaux. Pour cela, il faut r\u00e9aliser un regroupement via la clause GROUP BY Compter les communes par d\u00e9partement et calculer la population totale 1 2 3 4 5 6 7 8 9 -- Regrouper des donn\u00e9es -- Compter le nombre de communes par d\u00e9partement SELECT depart , count ( code_insee ) AS nb_commune , sum ( population ) AS total_population FROM z_formation . commune WHERE True GROUP BY depart ORDER BY nb_commune DESC Calculer des statistiques sur l'aire des communes pour chaque d\u00e9partement 1 2 3 4 5 6 7 8 SELECT depart , count ( id_commune ) AS nb , min ( ST_Area ( geom ) / 10000 ):: int AS min_aire_ha , max ( ST_Area ( geom ) / 10000 ):: int AS max_aire_ha , avg ( ST_Area ( geom ) / 10000 ):: int AS moy_aire_ha , sum ( ST_Area ( geom ) / 10000 ):: int AS total_aire_ha FROM z_formation . commune GROUP BY depart Compter le nombre de routes par nature 1 2 3 4 5 6 -- Compter le nombre de routes par nature SELECT count ( id_route ) AS nb_route , nature FROM z_formation . route WHERE True GROUP BY nature ORDER BY nb_route DESC Compter le nombre de routes par nature et par sens 1 2 3 4 5 SELECT count ( id_route ) AS nb_route , nature , sens FROM z_formation . route WHERE True GROUP BY nature , sens ORDER BY nature , sens DESC Les caculs sur des ensembles group\u00e9s peuvent aussi \u00eatre r\u00e9alis\u00e9 sur les g\u00e9om\u00e9tries. . Les plus utilis\u00e9s sont ST_Collect qui regroupe les g\u00e9om\u00e9tries dans une multi-g\u00e9om\u00e9trie, ST_Union qui fusionne les g\u00e9om\u00e9tries. Par exemple, on peut souhaiter trouver l' enveloppe convexe autour de points (\u00e9lastique tendu autour d'un groupe de points). Ici, nous regroupons les lieux-dits par nature (ce qui n'a pas beaucoup de sens, mais c'est pour l'exemple). Dans ce cas, il faut faire une sous-requ\u00eate pour filtrer seulement les r\u00e9sultats de type polygone (car s'il y a seulement 1 ou 2 objets par nature, alors on ne peut cr\u00e9er de polygone) 1 2 3 4 5 6 7 8 9 10 11 SELECT * FROM ( SELECT nature , -- ST_Convexhull renvoie l'enveloppe convexe ST_Convexhull ( ST_Collect ( geom )) AS geom FROM z_formation . lieu_dit_habite GROUP BY nature ) AS source -- GeometryType renvoie le type de g\u00e9om\u00e9trie WHERE Geometrytype ( geom ) = 'POLYGON' Attention, on doit donner un alias \u00e0 la sous-requ\u00eate (ici source ) Un autre exemple sur les bornes. Ici, on groupe les bornes par identifiant pair ou impair, et on calcule l'enveloppe convexe 1 2 3 4 SELECT count ( id_borne ), (( id_borne % 2 ) = 0 ) AS pair , ( st_convexhull ( ST_Collect ( geom ))) AS geom FROM z_formation . borne_incendie GROUP BY pair On peut r\u00e9aliser l'\u00e9quivalent d'un DISSOLVE de QGIS en regroupant les g\u00e9om\u00e9tries via ST_Union . Par exemple fusionner l'ensemble des communes pour construire les g\u00e9om\u00e9tries des d\u00e9partements: 1 2 3 4 5 6 7 8 9 SELECT depart , count ( id_commune ) AS nb_com , -- ST_Union cr\u00e9e une seule g\u00e9om\u00e9trie en fusionnant les g\u00e9om\u00e9tries. ST_Union ( geom ) AS geom FROM z_formation . commune GROUP BY depart Attention, cette requ\u00eate est lourde, et devra \u00eatre enregistr\u00e9e comme une table. Continuer vers Rassembler des donn\u00e9es: UNION ALL Quiz # \u00c9crire une requ\u00eate retournant pour les d\u00e9partements 'SEINE-MARITIME' et 'EURE', leur nom, le nombre de communes ainsi que la surface et la surface de l'enveloppe convexe en m\u00e8tre carr\u00e9 sous forme d'entier. 1 2 3 4 5 6 7 SELECT depart , count ( id_commune ) AS nb_commune , ST_Area ( ST_Collect ( geom )):: int8 AS surface , ST_Area ( ST_Convexhull ( ST_Collect ( geom ))):: int8 AS surface_enveloppe_convexe FROM z_formation . commune WHERE depart IN ( 'SEINE-MARITIME' , 'EURE' ) GROUP BY depart","title":"Regrouper"},{"location":"group_data/#grouper-des-donnees-et-calculer-des-statistiques","text":"Les fonctions d'agr\u00e9gat dans PostgreSQL","title":"Grouper des donn\u00e9es et calculer des statistiques"},{"location":"group_data/#valeurs-distinctes-dun-champ","text":"On souhaite r\u00e9cup\u00e9rer toutes les valeurs possibles d'un champ 1 2 3 4 5 6 7 8 9 -- V\u00e9rifier les valeurs distinctes d'un champ: table commune SELECT DISTINCT depart FROM z_formation . commune ORDER BY depart -- idem sur la table lieu_dit_habite SELECT DISTINCT nature FROM z_formation . lieu_dit_habite ORDER BY nature","title":"Valeurs distinctes d'un champ"},{"location":"group_data/#regrouper-des-donnees-en-specifiant-les-champs-de-regroupement","text":"Certains calculs n\u00e9cessitent le regroupement de lignes, comme les moyennes, les sommes ou les totaux. Pour cela, il faut r\u00e9aliser un regroupement via la clause GROUP BY Compter les communes par d\u00e9partement et calculer la population totale 1 2 3 4 5 6 7 8 9 -- Regrouper des donn\u00e9es -- Compter le nombre de communes par d\u00e9partement SELECT depart , count ( code_insee ) AS nb_commune , sum ( population ) AS total_population FROM z_formation . commune WHERE True GROUP BY depart ORDER BY nb_commune DESC Calculer des statistiques sur l'aire des communes pour chaque d\u00e9partement 1 2 3 4 5 6 7 8 SELECT depart , count ( id_commune ) AS nb , min ( ST_Area ( geom ) / 10000 ):: int AS min_aire_ha , max ( ST_Area ( geom ) / 10000 ):: int AS max_aire_ha , avg ( ST_Area ( geom ) / 10000 ):: int AS moy_aire_ha , sum ( ST_Area ( geom ) / 10000 ):: int AS total_aire_ha FROM z_formation . commune GROUP BY depart Compter le nombre de routes par nature 1 2 3 4 5 6 -- Compter le nombre de routes par nature SELECT count ( id_route ) AS nb_route , nature FROM z_formation . route WHERE True GROUP BY nature ORDER BY nb_route DESC Compter le nombre de routes par nature et par sens 1 2 3 4 5 SELECT count ( id_route ) AS nb_route , nature , sens FROM z_formation . route WHERE True GROUP BY nature , sens ORDER BY nature , sens DESC Les caculs sur des ensembles group\u00e9s peuvent aussi \u00eatre r\u00e9alis\u00e9 sur les g\u00e9om\u00e9tries. . Les plus utilis\u00e9s sont ST_Collect qui regroupe les g\u00e9om\u00e9tries dans une multi-g\u00e9om\u00e9trie, ST_Union qui fusionne les g\u00e9om\u00e9tries. Par exemple, on peut souhaiter trouver l' enveloppe convexe autour de points (\u00e9lastique tendu autour d'un groupe de points). Ici, nous regroupons les lieux-dits par nature (ce qui n'a pas beaucoup de sens, mais c'est pour l'exemple). Dans ce cas, il faut faire une sous-requ\u00eate pour filtrer seulement les r\u00e9sultats de type polygone (car s'il y a seulement 1 ou 2 objets par nature, alors on ne peut cr\u00e9er de polygone) 1 2 3 4 5 6 7 8 9 10 11 SELECT * FROM ( SELECT nature , -- ST_Convexhull renvoie l'enveloppe convexe ST_Convexhull ( ST_Collect ( geom )) AS geom FROM z_formation . lieu_dit_habite GROUP BY nature ) AS source -- GeometryType renvoie le type de g\u00e9om\u00e9trie WHERE Geometrytype ( geom ) = 'POLYGON' Attention, on doit donner un alias \u00e0 la sous-requ\u00eate (ici source ) Un autre exemple sur les bornes. Ici, on groupe les bornes par identifiant pair ou impair, et on calcule l'enveloppe convexe 1 2 3 4 SELECT count ( id_borne ), (( id_borne % 2 ) = 0 ) AS pair , ( st_convexhull ( ST_Collect ( geom ))) AS geom FROM z_formation . borne_incendie GROUP BY pair On peut r\u00e9aliser l'\u00e9quivalent d'un DISSOLVE de QGIS en regroupant les g\u00e9om\u00e9tries via ST_Union . Par exemple fusionner l'ensemble des communes pour construire les g\u00e9om\u00e9tries des d\u00e9partements: 1 2 3 4 5 6 7 8 9 SELECT depart , count ( id_commune ) AS nb_com , -- ST_Union cr\u00e9e une seule g\u00e9om\u00e9trie en fusionnant les g\u00e9om\u00e9tries. ST_Union ( geom ) AS geom FROM z_formation . commune GROUP BY depart Attention, cette requ\u00eate est lourde, et devra \u00eatre enregistr\u00e9e comme une table. Continuer vers Rassembler des donn\u00e9es: UNION ALL","title":"Regrouper des donn\u00e9es en sp\u00e9cifiant les champs de regroupement"},{"location":"group_data/#quiz","text":"\u00c9crire une requ\u00eate retournant pour les d\u00e9partements 'SEINE-MARITIME' et 'EURE', leur nom, le nombre de communes ainsi que la surface et la surface de l'enveloppe convexe en m\u00e8tre carr\u00e9 sous forme d'entier. 1 2 3 4 5 6 7 SELECT depart , count ( id_commune ) AS nb_commune , ST_Area ( ST_Collect ( geom )):: int8 AS surface , ST_Area ( ST_Convexhull ( ST_Collect ( geom ))):: int8 AS surface_enveloppe_convexe FROM z_formation . commune WHERE depart IN ( 'SEINE-MARITIME' , 'EURE' ) GROUP BY depart","title":"Quiz"},{"location":"import_data/","text":"Importer des donn\u00e9es # Pour la formation, on doit importer des donn\u00e9es pour pouvoir travailler. QGIS poss\u00e8de plusieurs outils pour r\u00e9aliser cette importation dans PostgreSQL. Import d'une couche depuis QGIS # On doit charger au pr\u00e9alable la couche source dans QGIS (SHP, TAB, etc.), puis on doit v\u00e9rifier : la projection , id\u00e9alement EPSG:2154 l' encodage : UTF-8, ISO-8859-15 ? Il faut ouvrir la table attributaire, et v\u00e9rifier si les accents sont bien affich\u00e9s. Sinon choisir le bon encodage dans l'onglet G\u00e9n\u00e9ral des propri\u00e9t\u00e9s de la couche les champs : noms, type, contenu Pour importer, on utilise le bouton Import de couche/fichier du gestionnaire de bdd. On choisit par exemple le fichier des communes: on clique sur Mettre \u00e0 jour les options on choisit le nom de la couche et le sch\u00e9ma z_formation on coche bien les 2 cases du bas pour convertir les noms de champ en minuscule (Convert fieldnames to lowercase) et pour cr\u00e9er l'index spatial Apr\u00e8s l'import, on peut cliquer, dans le panneau de gauche, sur le nom de la couche cr\u00e9\u00e9e et parcourir les donn\u00e9es avec l'onglet Table . Si on souhaite comparer avec la couche d'origine, il suffit de charger la table, en double-cliquant dessus dans l'arbre (ou via les autres outils de QGIS) NB : si un champ s'appelle d\u00e9j\u00e0 id dans la donn\u00e9e source, et qu'il contient des valeurs dupliqu\u00e9es, ou des valeurs textuelles, alors il faut cocher la case Cl\u00e9 primaire dans l'outil d'import, puis choisir un nom diff\u00e9rent pour que QGIS cr\u00e9e ce nouvel identifiant dans le bon format (entier autoincr\u00e9ment\u00e9 via une s\u00e9quence, qu'on appelle aussi serial). Par ex: id_commune R\u00e9importer une donn\u00e9e dans une table existante. # Avec suppression de la table puis recr\u00e9ation. # Il suffit d'utiliser le m\u00eame outil d'import via le gestionnaire de bdd, et cocher la case Remplacer la table de destination si existante . Attention, cela supprime la table avant de la recr\u00e9er et de la remplir, ce qui peut entra\u00eener des effets de bord (par exemple, on perd les droits d\u00e9finis) Avec vidage puis ajout des nouvelles donn\u00e9es # Imaginons qu'on ait donn\u00e9 tous les droits sur les tables du sch\u00e9ma, par exemple via cette requ\u00eate 1 2 3 4 5 -- Ajout des droits un sch\u00e9ma et sur toutes les tables d'un sch\u00e9ma GRANT ALL ON SCHEMA z_formation TO \"unutilisateur\" ; GRANT ALL PRIVILEGES ON ALL TABLES IN SCHEMA z_formation TO \"unutilisateur\" ; GRANT ALL ON SCHEMA z_formation TO \"unepersonne\" ; GRANT ALL PRIVILEGES ON ALL TABLES IN SCHEMA z_formation TO \"unepersonne\" ; Ensuite, on souhaite r\u00e9importer le SHP, sans perdre les droits : on doit d'abord vider la table puis reimporter les donn\u00e9es , sans cocher la case Remplacer la table de destination si existante 1 2 3 -- Vider une table en remettant \u00e0 z\u00e9ro la s\u00e9quence -- qui permet d'autoincr\u00e9menter le champ id (la cl\u00e9 primaire) TRUNCATE TABLE z_formation . commune RESTART IDENTITY ; Ensuite, on importe via l'outil sp\u00e9cifique du menu Traitement / Bo\u00eete \u00e0 outils . Chercher \"export\" dans le champ du haut (Rechercher...), et lancer l'algorithme Exporter vers PostgreSQL (connexions disponibles) de GDAL . Il faut choisir les options suivantes: choisir la bonne connexion , la couche en entr\u00e9e, etc. choisir le sch\u00e9ma , par exemple z_formation choisir le nom de la table , par exemple commune laisser id dans le champ Clef primaire ou choisir le champ appropri\u00e9 d\u00e9cocher \u00c9craser la table existante cocher Ajouter \u00e0 la table existante laisser le reste par d\u00e9faut. Lancer l'algorithme, et v\u00e9rifier une fois les donn\u00e9es import\u00e9es que les nouvelles donn\u00e9es ont bien \u00e9t\u00e9 ajout\u00e9es \u00e0 la table. Importer plusieurs couches en batch # Il est possible d'utiliser l'outil Importer un vecteur vers une base de donn\u00e9es PostGIS (connexions disponibles) par lot. Pour cela, une fois la bo\u00eete de dialogue de cet algorithme ouverte, cliquer sur le bouton Ex\u00e9cuter comme processus de lot . Cela affiche un tableau, ou chaque ligne repr\u00e9sente les variables d'entr\u00e9e d'un algorithme. Vous pouvez cr\u00e9er manuellement chaque ligne, ou choisir directement les couches depuis votre projet QGIS. Voir la documentation QGIS pour plus de d\u00e9tail: https://docs.qgis.org/latest/fr/docs/user_manual/processing/batch.html Continuer vers S\u00e9lectionner des donn\u00e9es: SELECT","title":"Import des donn\u00e9es"},{"location":"import_data/#importer-des-donnees","text":"Pour la formation, on doit importer des donn\u00e9es pour pouvoir travailler. QGIS poss\u00e8de plusieurs outils pour r\u00e9aliser cette importation dans PostgreSQL.","title":"Importer des donn\u00e9es"},{"location":"import_data/#import-dune-couche-depuis-qgis","text":"On doit charger au pr\u00e9alable la couche source dans QGIS (SHP, TAB, etc.), puis on doit v\u00e9rifier : la projection , id\u00e9alement EPSG:2154 l' encodage : UTF-8, ISO-8859-15 ? Il faut ouvrir la table attributaire, et v\u00e9rifier si les accents sont bien affich\u00e9s. Sinon choisir le bon encodage dans l'onglet G\u00e9n\u00e9ral des propri\u00e9t\u00e9s de la couche les champs : noms, type, contenu Pour importer, on utilise le bouton Import de couche/fichier du gestionnaire de bdd. On choisit par exemple le fichier des communes: on clique sur Mettre \u00e0 jour les options on choisit le nom de la couche et le sch\u00e9ma z_formation on coche bien les 2 cases du bas pour convertir les noms de champ en minuscule (Convert fieldnames to lowercase) et pour cr\u00e9er l'index spatial Apr\u00e8s l'import, on peut cliquer, dans le panneau de gauche, sur le nom de la couche cr\u00e9\u00e9e et parcourir les donn\u00e9es avec l'onglet Table . Si on souhaite comparer avec la couche d'origine, il suffit de charger la table, en double-cliquant dessus dans l'arbre (ou via les autres outils de QGIS) NB : si un champ s'appelle d\u00e9j\u00e0 id dans la donn\u00e9e source, et qu'il contient des valeurs dupliqu\u00e9es, ou des valeurs textuelles, alors il faut cocher la case Cl\u00e9 primaire dans l'outil d'import, puis choisir un nom diff\u00e9rent pour que QGIS cr\u00e9e ce nouvel identifiant dans le bon format (entier autoincr\u00e9ment\u00e9 via une s\u00e9quence, qu'on appelle aussi serial). Par ex: id_commune","title":"Import d'une couche depuis QGIS"},{"location":"import_data/#reimporter-une-donnee-dans-une-table-existante","text":"","title":"R\u00e9importer une donn\u00e9e dans une table existante."},{"location":"import_data/#avec-suppression-de-la-table-puis-recreation","text":"Il suffit d'utiliser le m\u00eame outil d'import via le gestionnaire de bdd, et cocher la case Remplacer la table de destination si existante . Attention, cela supprime la table avant de la recr\u00e9er et de la remplir, ce qui peut entra\u00eener des effets de bord (par exemple, on perd les droits d\u00e9finis)","title":"Avec suppression de la table puis recr\u00e9ation."},{"location":"import_data/#avec-vidage-puis-ajout-des-nouvelles-donnees","text":"Imaginons qu'on ait donn\u00e9 tous les droits sur les tables du sch\u00e9ma, par exemple via cette requ\u00eate 1 2 3 4 5 -- Ajout des droits un sch\u00e9ma et sur toutes les tables d'un sch\u00e9ma GRANT ALL ON SCHEMA z_formation TO \"unutilisateur\" ; GRANT ALL PRIVILEGES ON ALL TABLES IN SCHEMA z_formation TO \"unutilisateur\" ; GRANT ALL ON SCHEMA z_formation TO \"unepersonne\" ; GRANT ALL PRIVILEGES ON ALL TABLES IN SCHEMA z_formation TO \"unepersonne\" ; Ensuite, on souhaite r\u00e9importer le SHP, sans perdre les droits : on doit d'abord vider la table puis reimporter les donn\u00e9es , sans cocher la case Remplacer la table de destination si existante 1 2 3 -- Vider une table en remettant \u00e0 z\u00e9ro la s\u00e9quence -- qui permet d'autoincr\u00e9menter le champ id (la cl\u00e9 primaire) TRUNCATE TABLE z_formation . commune RESTART IDENTITY ; Ensuite, on importe via l'outil sp\u00e9cifique du menu Traitement / Bo\u00eete \u00e0 outils . Chercher \"export\" dans le champ du haut (Rechercher...), et lancer l'algorithme Exporter vers PostgreSQL (connexions disponibles) de GDAL . Il faut choisir les options suivantes: choisir la bonne connexion , la couche en entr\u00e9e, etc. choisir le sch\u00e9ma , par exemple z_formation choisir le nom de la table , par exemple commune laisser id dans le champ Clef primaire ou choisir le champ appropri\u00e9 d\u00e9cocher \u00c9craser la table existante cocher Ajouter \u00e0 la table existante laisser le reste par d\u00e9faut. Lancer l'algorithme, et v\u00e9rifier une fois les donn\u00e9es import\u00e9es que les nouvelles donn\u00e9es ont bien \u00e9t\u00e9 ajout\u00e9es \u00e0 la table.","title":"Avec vidage puis ajout des nouvelles donn\u00e9es"},{"location":"import_data/#importer-plusieurs-couches-en-batch","text":"Il est possible d'utiliser l'outil Importer un vecteur vers une base de donn\u00e9es PostGIS (connexions disponibles) par lot. Pour cela, une fois la bo\u00eete de dialogue de cet algorithme ouverte, cliquer sur le bouton Ex\u00e9cuter comme processus de lot . Cela affiche un tableau, ou chaque ligne repr\u00e9sente les variables d'entr\u00e9e d'un algorithme. Vous pouvez cr\u00e9er manuellement chaque ligne, ou choisir directement les couches depuis votre projet QGIS. Voir la documentation QGIS pour plus de d\u00e9tail: https://docs.qgis.org/latest/fr/docs/user_manual/processing/batch.html Continuer vers S\u00e9lectionner des donn\u00e9es: SELECT","title":"Importer plusieurs couches en batch"},{"location":"join_data/","text":"Les jointures # Les jointures permettent de r\u00e9cup\u00e9rer des donn\u00e9es en relation les unes par rapport aux autres. Les jointures attributaires # La condition de jointure est faite sur des champs non g\u00e9om\u00e9triques. Par exemple une \u00e9galit\u00e9 (code, identifiant). Exemple 1: zonages et communes # R\u00e9cup\u00e9ration des informations de la commune pour chaque zonage 1 2 3 4 5 6 7 -- Jointure attributaire: r\u00e9cup\u00e9ration du nom de la commune pour chacun des zonages SELECT z . * , c . nom FROM z_formation . zone_urba AS z JOIN z_formation . commune AS c ON z . insee = c . code_insee -- IMPORTANT: ne pas oublier le ON cad le crit\u00e8re de jointure, -- sous peine de \"produit cart\u00e9sien\" (calcul co\u00fbteux de tous les possibles) ; Il est souvent int\u00e9ressant, pour des donn\u00e9es volumineuses, de cr\u00e9er un index sur le champ de jointure (par exemple ici sur les champs insee et ccocom . Exemple 2: observations et communes # On cr\u00e9e une table de points qui contiendra des observations 1 2 3 4 5 6 7 8 9 10 11 12 13 14 -- cr\u00e9ation CREATE TABLE z_formation . observation ( id serial NOT NULL PRIMARY KEY , date date DEFAULT ( now ()):: date NOT NULL , description text , geom public . geometry ( Point , 2154 ), code_insee character varying ( 5 ) ); CREATE INDEX sidx_observation_geom ON z_formation . observation USING gist ( geom ); -- on y met des donn\u00e9es INSERT INTO z_formation . observation VALUES ( 1 , '2020-07-08' , 'un' , '01010000206A080000D636D95AFB832141279BD2C8FEA65A41' , '76618' ); INSERT INTO z_formation . observation VALUES ( 2 , '2020-07-08' , 'deux' , '01010000206A08000010248E173E37224156920AEA21525A41' , '27213' ); INSERT INTO z_formation . observation VALUES ( 3 , '2020-07-08' , 'trois' , '01010000206A08000018BF3048EA112341183933F6CC885A41' , NULL ); On fait une jointure attributaire entre les points des observations et les communes 1 2 3 4 5 6 7 8 9 10 SELECT -- tous les champs de la table observation o . * , -- le nom de la commune c . nom , -- l'aire enti\u00e8re en hectares ST_area ( c . geom ):: integer / 10000 AS surface_commune FROM z_formation . observation AS o JOIN z_formation . commune AS c ON o . code_insee = c . code_insee WHERE True R\u00e9sultat: id date description geom code_insee nom surface_commune 2 2020-07-08 deux .... 27213 Vexin-sur-Epte 11434 1 2020-07-08 un .... 76618 Petit-Caux 9243 On ne r\u00e9cup\u00e8re ici que 2 lignes alors qu'il y a bien 3 observations dans la table. Pour r\u00e9cup\u00e9rer les 3 lignes, on doit faire une jointure LEFT. On peut utiliser un CASE WHEN pour tester si la commune est trouv\u00e9e sous chaque point 1 2 3 4 5 6 7 8 9 SELECT o . * , c . nom , ST_area ( c . geom ):: integer / 10000 AS surface_commune , CASE WHEN c . code_insee IS NULL THEN 'pas de commune' ELSE 'ok' END AS test_commune FROM z_formation . observation AS o LEFT JOIN z_formation . commune AS c ON o . code_insee = c . code_insee WHERE True R\u00e9sultat id date description geom code_insee nom surface_commune test_commune 2 2020-07-08 deux .... 27213 Vexin-sur-Epte 11434 ok 1 2020-07-08 un .... 76618 Petit-Caux 9243 ok 3 2020-07-08 trois .... Null Null Null pas de commune Les jointures spatiales # Le crit\u00e8re de jointure peut \u00eatre une condition spatiale . On r\u00e9alise souvent une jointure par intersection ou par proximit\u00e9 . Joindre des points avec des polygones # Un exemple classique de r\u00e9cup\u00e9ration des donn\u00e9es de la table commune (nom, etc.) depuis une table de points. 1 2 3 4 5 6 7 8 9 -- Pour chaque lieu-dit, on veut le nom de la commune SELECT l . id_lieu_dit_habite , l . nom , c . nom AS nom_commune , c . code_insee , l . geom FROM \"z_formation\" . lieu_dit_habite AS l JOIN \"z_formation\" . commune AS c ON st_intersects ( c . geom , l . geom ) ORDER BY l . nom id_lieu_dit_habite nom nom_commune code_insee geom 58 Abbaye du Valasse Gruchet-le-Valasse 76329 .... 1024 Ablemont Bacqueville-en-Caux 76051 .... 1043 Agranville Douvrend 76220 .... 1377 All des Artisans Mesnils-sur-Iton 27198 .... 1801 All\u00e9e des Maronniers Heudebouville 27332 .... 1293 Alliquerville Trouville 76715 .... 507 Alventot Sainte-H\u00e9l\u00e8ne-Bondeville 76587 .... 555 Alvinbuc Veauville-l\u00e8s-Baons 76729 .... 69 Ancien h\u00f4tel de ville Rouen 76540 .... On peut facilement inverser la table principale pour afficher les lignes ordonn\u00e9es par commune. 1 2 3 4 5 6 7 SELECT c . nom , c . code_insee , l . id_lieu_dit_habite , l . nom FROM \"z_formation\" . commune AS c JOIN \"z_formation\" . lieu_dit_habite AS l ON st_intersects ( c . geom , l . geom ) ORDER BY c . nom nom code_insee id_lieu_dit_habite nom Aclou 27001 107 Manoir de la Haule Acquigny 27003 106 Manoir de Becdal Ailly 27005 596 Quaizes Ailly 27005 595 Ingremare Ailly 27005 594 Gruchet Alizay 27008 667 Le Solitaire Ambenay 27009 204 Les Siaules Ambenay 27009 201 Les Renardieres Ambenay 27009 202 Le Culoron On a plusieurs lignes par commune, autant que de lieux-dits pour cette commune. Par contre, comme ce n'est pas une jointure LEFT, on ne trouve que des r\u00e9sultats pour les communes qui ont des lieux-dits. On pourrait aussi faire des statistiques, en regroupant par les champs de la table principale, ici les communes. 1 2 3 4 5 6 7 8 9 10 SELECT c . nom , c . code_insee , count ( l . id_lieu_dit_habite ) AS nb_lieu_dit , c . geom FROM \"z_formation\" . commune AS c JOIN \"z_formation\" . lieu_dit_habite AS l ON st_intersects ( c . geom , l . geom ) GROUP BY c . nom , c . code_insee , c . geom ORDER BY nb_lieu_dit DESC LIMIT 10 nom code_insee nb_lieu_dit geom Heudebouville 27332 61 .... Mesnils-sur-Iton 27198 52 .... Rouen 76540 20 .... Saint-Sa\u00ebns 76648 19 .... Les Grandes-Ventes 76321 19 .... Mesnil-en-Ouche 27049 18 .... Quincampoix 76517 18 .... Joindre des lignes avec des polygones # R\u00e9cup\u00e9rer le code commune de chaque chemin, par intersection entre le chemin et la commune . Jointure spatiale simple entre les g\u00e9om\u00e9tries brutes # 1 2 3 4 5 6 7 8 9 -- Ici, on peut r\u00e9cup\u00e9rer plusieurs fois le m\u00eame chemin -- s'il passe par plusieurs communes SELECT v . * , c . nom , c . code_insee FROM \"z_formation\" . chemin AS v JOIN \"z_formation\" . commune AS c ON ST_Intersects ( v . geom , c . geom ) ORDER BY id_chemin , nom Cela peut renvoyer plusieurs lignes par chemin, car chaque chemin peut passer par plusieurs communes. Jointure spatiale entre le centro\u00efde des chemins et la g\u00e9om\u00e9trie des communes # On peut utiliser le centro\u00efde de chaque chemin pour avoir un seul objet par chemin comme r\u00e9sultat. 1 2 3 4 5 6 7 8 9 10 11 -- cr\u00e9ation de l'index CREATE INDEX ON z_formation . chemin USING gist ( ST_Centroid ( geom )); -- Jointure spatiale -- On ne veut qu'une seule ligne par chemin -- Donc on fait l'intersection entre le centro\u00efde des chemins (pour avoir un point) et les communes SELECT v . * , c . nom , c . code_insee FROM \"z_formation\" . chemin AS v JOIN \"z_formation\" . commune AS c ON ST_Intersects ( ST_Centroid ( v . geom ), c . geom ) NB: Attention, dans ce cas, l'index spatial sur la g\u00e9om\u00e9trie des chemins n'est pas utilis\u00e9. C'est pour cela que nous avons cr\u00e9\u00e9 un index spatial sur ST_Centroid(geom) pour la table des chemins. A l'inverse, on peut vouloir faire des statistiques pour chaque commune via jointure spatiale. Par exemple le nombre de chemins et le total des longueurs par commune. 1 2 3 4 5 6 7 8 9 10 11 -- A l'inverse, on veut r\u00e9cup\u00e9rer des statistiques par commune -- On veut une ligne par commune, avec des donn\u00e9es sur les voies SELECT c . id_commune , c . nom , c . code_insee , count ( v . id_chemin ) AS nb_chemin , sum ( st_length ( v . geom )) AS somme_longueur_chemins_entiers FROM z_formation . commune AS c JOIN z_formation . chemin AS v ON st_intersects ( c . geom , st_centroid ( v . geom )) GROUP BY c . id_commune , c . nom , c . code_insee ; Utilisation d'une jointure LEFT pour garder les communes sans chemins # La requ\u00eate pr\u00e9c\u00e9dente ne renvoie pas de lignes pour les communes qui n'ont pas de chemin dont le centro\u00efde est dans une commune. C'est une jointure de type INNER JOIN Si on veut quand m\u00eame r\u00e9cup\u00e9rer ces communes, on fait une jointure LEFT JOIN : pour les lignes sans chemins, les champs li\u00e9s \u00e0 la table des chemins seront mis \u00e0 NULL. 1 2 3 4 5 6 7 8 9 SELECT c . id_commune , c . nom , c . code_insee , count ( v . id_chemin ) AS nb_chemin , sum ( st_length ( v . geom )) AS somme_longueur_chemins_entiers FROM z_formation . commune AS c LEFT JOIN z_formation . chemin AS v ON st_intersects ( c . geom , st_centroid ( v . geom )) GROUP BY c . id_commune , c . nom , c . code_insee ; C'est beaucoup plus long , car la requ\u00eate n'utilise pas d'abord l'intersection, donc l'index spatial des communes, mais fait un parcours de toutes les lignes des communes, puis un calcul d'intersection. Pour acc\u00e9l\u00e9rer la requ\u00eate, on doit cr\u00e9er l'index sur les centro\u00efdes des chemins 1 CREATE INDEX ON z_formation . chemin USING GIST ( ST_Centroid ( geom )) puis la relancer. Dans cet exemple, on passe de 100 secondes \u00e0 1 seconde, gr\u00e2ce \u00e0 ce nouvel index spatial. Affiner le r\u00e9sultat en d\u00e9coupant les chemins # Dans la requ\u00eate pr\u00e9c\u00e9dente, on calculait la longueur totale de chaque chemin, pas le morceau exacte qui est sur chaque commune . Pour cela, on va utiliser la fonction ST_Intersection . La requ\u00eate va \u00eatre plus co\u00fbteuse, car il faut r\u00e9aliser le d\u00e9coupage des lignes des chemins par les polygones des communes. On va d\u00e9couper exactement les chemins par commune et r\u00e9cup\u00e9rer les informations 1 2 3 4 5 6 7 8 9 10 11 12 13 14 CREATE TABLE z_formation . decoupe_chemin_par_commune AS -- D\u00e9couper les chemins par commune SELECT -- id unique -- infos du chemin l . id AS id_chemin , -- infos de la commune c . nom , c . code_insee , ST_Multi ( st_collectionextract ( ST_Intersection ( c . geom , l . geom ), 2 )):: geometry ( multilinestring , 2154 ) AS geom FROM \"z_formation\" . commune AS c JOIN \"z_formation\" . chemin AS l ON st_intersects ( c . geom , l . geom ) ; CREATE INDEX ON z_formation . decoupe_chemin_par_commune USING GIST ( geom ); NB : Attention \u00e0 ne pas confondre ST_Intersects qui renvoie vrai ou faux, et ST_Intersection qui renvoie la g\u00e9om\u00e9trie issue du d\u00e9coupage d'une g\u00e9om\u00e9trie par une autre. Joindre des polygones avec des polygones # On peut bien s\u00fbr r\u00e9aliser des jointures spatiales entre 2 couches de polygones , et d\u00e9couper les polygones par intersection. Attention, les performances sont forc\u00e9ment moins bonnes qu'avec des points. Trouver l'ensemble des zonages PLU pour les parcelles du Havre. On va r\u00e9cup\u00e9rer plusieurs r\u00e9sultats pour chaque parcelle si plusieurs zonages chevauchent une parcelle. 1 2 3 4 5 6 7 8 -- Jointure spatiale SELECT p . id_parcelle , z . libelle , z . libelong , z . typezone FROM z_formation . parcelle_havre AS p JOIN z_formation . zone_urba AS z ON st_intersects ( z . geom , p . geom ) WHERE True Compter pour chaque parcelle le nombre de zonages en intersection: on veut une seule ligne par parcelle . 1 2 3 4 5 6 7 8 9 SELECT p . id_parcelle , count ( z . libelle ) AS nombre_zonage FROM z_formation . parcelle_havre AS p JOIN z_formation . zone_urba AS z ON st_intersects ( z . geom , p . geom ) WHERE True GROUP BY p . id_parcelle ORDER BY nombre_zonage DESC D\u00e9couper les parcelles par les zonages, et pouvoir calculer les surfaces des zonages, et le pourcentage par rapport \u00e0 la surface de chaque parcelle. On essaye le SQL suivant: 1 2 3 4 5 6 7 8 9 10 SELECT p . id_parcelle , z . libelle , z . libelong , z . typezone , -- d\u00e9couper les g\u00e9om\u00e9tries st_intersection ( z . geom , p . geom ) AS geom FROM z_formation . parcelle_havre AS p JOIN z_formation . zone_urba AS z ON st_intersects ( z . geom , p . geom ) WHERE True ORDER BY p . id_parcelle Il renvoit l'erreur 1 ERREUR: Error performing intersection: TopologyException: Input geom 1 is invalid: Self-intersection at or near point 492016.26000489673 6938870.663846286 at 492016.26000489673 6938870.663846286 On a ici des soucis de validit\u00e9 de g\u00e9om\u00e9trie . Il nous faut donc corriger les g\u00e9om\u00e9tries avant de poursuivre. Voir chapitre sur la validation des g\u00e9om\u00e9tries. Une fois les g\u00e9om\u00e9tries valid\u00e9es, la requ\u00eate fonctionne. On l'utilise dans une sous-requ\u00eate pour cr\u00e9er une table et calculer les surfaces 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 -- suppression de la table DROP TABLE IF EXISTS z_formation . decoupe_zonage_parcelle ; -- cr\u00e9ation de la table avec calcul de pourcentage de surface CREATE TABLE z_formation . decoupe_zonage_parcelle AS SELECT row_number () OVER () AS id , source . * , ST_Area ( geom ) AS aire , 100 * ST_Area ( geom ) / aire_parcelle AS pourcentage FROM ( SELECT p . id_parcelle , p . id AS idpar , ST_Area ( p . geom ) AS aire_parcelle , z . id_zone_urba , z . libelle , z . libelong , z . typezone , -- d\u00e9couper les g\u00e9om\u00e9tries ( ST_Multi ( st_intersection ( z . geom , p . geom ))):: geometry ( MultiPolygon , 2154 ) AS geom FROM z_formation . parcelle_havre AS p JOIN z_formation . zone_urba AS z ON st_intersects ( z . geom , p . geom ) WHERE True ) AS source ; -- Ajout de la cl\u00e9 primaire ALTER TABLE z_formation . decoupe_zonage_parcelle ADD PRIMARY KEY ( id ); -- Ajout de l'index spatial CREATE INDEX ON z_formation . decoupe_zonage_parcelle USING GIST ( geom ); Faire un rapport des surfaces intersect\u00e9es de zonages sur une table principale # Par exemple, pour chacune des communes, on souhaite calculer la somme des surfaces intersect\u00e9e par chaque type de zone (parcs, znieff, etc.). Afin d'avoir \u00e0 disposition des donn\u00e9es de test pour cet exemple de rapport, nous allons cr\u00e9er 2 tables z_formation.parc_national et z_formation.znieff , et y ins\u00e9rer des fausses donn\u00e9es: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 -- Table des parcs nationaux CREATE TABLE IF NOT EXISTS z_formation . parc_national ( id serial primary key , nom text , geom geometry ( multipolygon , 2154 ) ); CREATE INDEX ON z_formation . parc_national USING GIST ( geom ); -- Table des znieff CREATE TABLE IF NOT EXISTS z_formation . znieff ( id serial primary key , nom_znieff text , geom geometry ( multipolygon , 2154 ) ); CREATE INDEX ON z_formation . znieff USING GIST ( geom ); On ins\u00e8re des polygones dans ces deux tables: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 -- donn\u00e9es de test -- parcs INSERT INTO z_formation . parc_national VALUES ( 1 , 'un' , '01060000206A0800000100000001030000000100000008000000C3F7DE73553D20411B3DC1FB0C625A410531F757E93D2041BAECB21FA85E5A41F35B09978081204195F05B9787595A41D61E4865A1A7204147BC8A3AC0605A41ED76A806317F2041A79F7E4876605A41B80752433C832041037846623A655A41E10ED595BA6120413CC1D1C18C685A41C3F7DE73553D20411B3DC1FB0C625A41' ); INSERT INTO z_formation . parc_national VALUES ( 2 , 'deux' , '01060000206A080000010000000103000000010000000900000024D68B4AE0412141AAAAAA3C685B5A4130642ACBD01421413A85AE4B72585A41CA08F0240E382141746C4BD107535A41FA30F7A78A4A2141524A29E544555A414796BF5CE63621414DD2E222A4565A416B92160F9B5D2141302807F981575A4130DC700B2E782141DC0ED50B6B5C5A4106FBB8C8294F214150AC17BF015E5A4124D68B4AE0412141AAAAAA3C685B5A41' ); INSERT INTO z_formation . parc_national VALUES ( 3 , 'trois' , '01060000206A0800000100000001030000000100000006000000918DCFE7E0861F4137AB79AF14515A411AE56040588A1F41642A43EEC74F5A41DF2EBB3CEBA41F418C31C66ADA4F5A4168864C9562A81F416E87EA40B8505A415CBC8A74C3A31F410FA4F63202515A41918DCFE7E0861F4137AB79AF14515A41' ); INSERT INTO z_formation . parc_national VALUES ( 4 , 'quatre' , '01060000206A080000010000000103000000010000000500000004474FE81DBA2041269A684EFD625A41AB17C51223C9204120B507BEAD605A4116329539BBF22041A3273886D5615A416F611F0FB6E32041FA1A9F0F4A645A4104474FE81DBA2041269A684EFD625A41' ); INSERT INTO z_formation . parc_national VALUES ( 5 , 'cinq' , '01060000206A0800000100000001030000000100000005000000F2E3C256231E2041E0ACE631AE535A41F7C823E772202041E89C73B6EF505A41B048BCC266362041DAC785A15E515A419E999911782F204180C9F223F8535A41F2E3C256231E2041E0ACE631AE535A41' ); SELECT pg_catalog . setval ( 'z_formation.parc_national_id_seq' , 5 , true ); -- znieff INSERT INTO z_formation . znieff VALUES ( 1 , 'uno' , '01060000206A08000001000000010300000001000000050000004039188C39D12041770A5DF74A4A5A413A54B7FBE9CE20410C5DA7C8F5455A41811042C0A4EA204130ECE38267475A416F611F0FB6E320417125FC66FB475A414039188C39D12041770A5DF74A4A5A41' ); INSERT INTO z_formation . znieff VALUES ( 2 , 'dos' , '01060000206A080000010000000103000000010000000500000076BEC6DF62492141513FFDF0525A5A417CA32770B24B21411EDBD22150595A419437ABB1F05421410F06E50CBF595A419437ABB1F0542141B022F1FE085A5A4176BEC6DF62492141513FFDF0525A5A41' ); INSERT INTO z_formation . znieff VALUES ( 3 , 'tres' , '01060000206A0800000100000001030000000100000005000000A6E6CD62DF5B2141B607528F585C5A41ACCB2EF32E5E2141C5DC3FA4E95B5A414CB7438DE46A2141C5DC3FA4E95B5A41B895F013CE62214189888850A55D5A41A6E6CD62DF5B2141B607528F585C5A41' ); INSERT INTO z_formation . znieff VALUES ( 4 , 'quatro' , '01060000206A0800000100000001030000000100000005000000CE857DF445102041985D7665365D5A41DA4F3F15E5142041339521C7305B5A41C2F7DE73553D2041927815D5E65A5A410393E50712252041B607528F585C5A41CE857DF445102041985D7665365D5A41' ); INSERT INTO z_formation . znieff VALUES ( 5 , 'cinco' , '01060000206A080000010000000103000000010000000500000045A632DC2B702041FD25CB033C5F5A41CEFDC334A373204115EB459D0E5C5A41F25B099780812041397A8257805D5A415755558D1A7720419E42D7F5855F5A4145A632DC2B702041FD25CB033C5F5A41' ); SELECT pg_catalog . setval ( 'z_formation.znieff_id_seq' , 5 , true ); Pour chaque commune, on souhaite calculer la somme des surfaces intersect\u00e9es par chaque type de zone. On doit donc utiliser toutes les tables de zonage (ici seulement 2 tables, mais c'est possible d'en ajouter) R\u00e9sultat attendu: id_commune code_insee nom surface_commune_ha somme_surface_parcs somme_surface_znieff 1139 27042 Barville 275.138028733401 87.2237204013011 None 410 27057 Bernienville 779.74546553394 None 5.26504189468878 1193 27061 Berthouville 757.19696570046 19.9975421896336 None 495 27074 Boisney 576.995877227961 0.107059260396721 None 432 27077 Boissey-le-Ch\u00e2tel 438.373848703835 434.510197417769 83.9289621127432 M\u00e9thode avec des sous-requ\u00eates 1 2 3 4 5 6 7 SELECT c . id_commune , c . code_insee , c . nom , ST_Area ( c . geom ) / 10000 AS surface_commune_ha , ( SELECT sum ( ST_Area ( ST_Intersection ( c . geom , p . geom )) / 10000 ) FROM z_formation . parc_national AS p WHERE ST_Intersects ( p . geom , c . geom ) ) AS surface_parc_national , ( SELECT sum ( ST_Area ( ST_Intersection ( c . geom , p . geom )) / 10000 ) FROM z_formation . znieff AS p WHERE ST_Intersects ( p . geom , c . geom ) ) AS surface_znieff FROM z_formation . commune AS c ORDER BY c . nom M\u00e9thode avec des jointures LEFT 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 SELECT -- champs choisis dans la table commune c . id_commune , c . code_insee , c . nom , -- surface en ha ST_Area ( c . geom ) / 10000 AS surface_commune_ha , -- somme des d\u00e9coupages des parcs par commune sum ( ST_Area ( ST_Intersection ( c . geom , p . geom )) / 10000 ) AS somme_surface_parcs , -- somme des d\u00e9coupages des znieff par commune sum ( ST_Area ( ST_Intersection ( c . geom , z . geom )) / 10000 ) AS somme_surface_znieff FROM z_formation . commune AS c -- jointure spatiale sur les parcs LEFT JOIN z_formation . parc_national AS p ON ST_Intersects ( c . geom , p . geom ) -- jointure spatiale sur les znieff LEFT JOIN z_formation . znieff AS z ON ST_Intersects ( c . geom , z . geom ) -- clause WHERE optionelle -- WHERE p.id IS NOT NULL OR z.id IS NOT NULL -- on regroupe sur les champs des communes GROUP BY c . id_commune , c . code_insee , c . nom -- on ordonne par nom ORDER BY c . nom Avantages : on peut int\u00e9grer facilement dans la clause WHERE des conditions sur les champs des tables jointes. Par exemple ne r\u00e9cup\u00e9rer que les lignes qui sont concern\u00e9es par un parc ou une znieff, via WHERE p.id IS NOT NULL OR z.id IS NOT NULL (comment\u00e9 ci-dessus pour le d\u00e9sactiver) On peut sortir plusieurs aggr\u00e9gats pour les tables jointes. Par exemple un d\u00e9compte des parcs, un d\u00e9compte des znieff ATTENTION: on peut avoir des doublons qui vont cr\u00e9er des erreurs. Voir cet exemple: http://sqlfiddle.com/#!17/73485c/2/0 cette m\u00e9thode peut poser des soucis de performance ATTENTION : il faut absolument avoir un index spatial sur le champ geom de toutes les tables le calcul de d\u00e9coupage des polygones des communes par ceux des zonages peut \u00eatre tr\u00e8s long (et l'index spatial ne sert \u00e0 rien ici) Distances et tampons entre couches # Pour chaque objets d'une table, on souhaite r\u00e9cup\u00e9rer des informations sur les objets proches d'une autre table . Au lieu d'utiliser un tampon puis une intersection, on utilise la fonction ST_DWithin On prend comme exemple la table des bornes \u00e0 incendie cr\u00e9\u00e9e pr\u00e9c\u00e9demment (remplie avec quelques donn\u00e9es de test). Trouver toutes les parcelles \u00e0 moins de 200m d'une borne \u00e0 incendie 1 2 3 4 5 6 7 8 SELECT p . id_parcelle , p . geom , b . id_borne , b . code , ST_Distance ( b . geom , p . geom ) AS distance FROM z_formation . parcelle_havre AS p JOIN z_formation . borne_incendie AS b ON ST_DWithin ( p . geom , b . geom , 200 ) ORDER BY id_parcelle , id_borne Attention, elle peut renvoyer plusieurs fois la m\u00eame parcelle si 2 bornes sont assez proches. Pour ne r\u00e9cup\u00e9rer que la borne la plus proche, on peut faire la requ\u00eate suivante. La clause DISTINCT ON permet de dire quel champ doit \u00eatre unique (ici id_parcelle). On ordonne ensuite par ce champ et par la distance pour prendre seulement la ligne correspondant \u00e0 la parcelle la plus proche 1 2 3 4 5 6 7 8 SELECT DISTINCT ON ( p . id_parcelle ) p . id_parcelle , p . geom , b . id_borne , b . code , ST_Distance ( b . geom , p . geom ) AS distance FROM z_formation . parcelle_havre AS p JOIN z_formation . borne_incendie AS b ON ST_DWithin ( p . geom , b . geom , 200 ) ORDER BY id_parcelle , distance Pour information, on peut v\u00e9rifier en cr\u00e9ant les tampons 1 2 3 4 5 6 7 -- Tampons non dissous SELECT id_borne , ST_Buffer ( geom , 200 ) AS geom FROM z_formation . borne_incendie -- Tampons dissous SELECT ST_Union ( ST_Buffer ( geom , 200 )) AS geom FROM z_formation . borne_incendie Un article int\u00e9ressant de Paul Ramsey sur le calcul de distance via l'op\u00e9rateur <-> pour trouver le plus proche voisin d'un objet. Continuer vers Fusionner des g\u00e9om\u00e9tries","title":"Jointures"},{"location":"join_data/#les-jointures","text":"Les jointures permettent de r\u00e9cup\u00e9rer des donn\u00e9es en relation les unes par rapport aux autres.","title":"Les jointures"},{"location":"join_data/#les-jointures-attributaires","text":"La condition de jointure est faite sur des champs non g\u00e9om\u00e9triques. Par exemple une \u00e9galit\u00e9 (code, identifiant).","title":"Les jointures attributaires"},{"location":"join_data/#exemple-1-zonages-et-communes","text":"R\u00e9cup\u00e9ration des informations de la commune pour chaque zonage 1 2 3 4 5 6 7 -- Jointure attributaire: r\u00e9cup\u00e9ration du nom de la commune pour chacun des zonages SELECT z . * , c . nom FROM z_formation . zone_urba AS z JOIN z_formation . commune AS c ON z . insee = c . code_insee -- IMPORTANT: ne pas oublier le ON cad le crit\u00e8re de jointure, -- sous peine de \"produit cart\u00e9sien\" (calcul co\u00fbteux de tous les possibles) ; Il est souvent int\u00e9ressant, pour des donn\u00e9es volumineuses, de cr\u00e9er un index sur le champ de jointure (par exemple ici sur les champs insee et ccocom .","title":"Exemple 1: zonages et communes"},{"location":"join_data/#exemple-2-observations-et-communes","text":"On cr\u00e9e une table de points qui contiendra des observations 1 2 3 4 5 6 7 8 9 10 11 12 13 14 -- cr\u00e9ation CREATE TABLE z_formation . observation ( id serial NOT NULL PRIMARY KEY , date date DEFAULT ( now ()):: date NOT NULL , description text , geom public . geometry ( Point , 2154 ), code_insee character varying ( 5 ) ); CREATE INDEX sidx_observation_geom ON z_formation . observation USING gist ( geom ); -- on y met des donn\u00e9es INSERT INTO z_formation . observation VALUES ( 1 , '2020-07-08' , 'un' , '01010000206A080000D636D95AFB832141279BD2C8FEA65A41' , '76618' ); INSERT INTO z_formation . observation VALUES ( 2 , '2020-07-08' , 'deux' , '01010000206A08000010248E173E37224156920AEA21525A41' , '27213' ); INSERT INTO z_formation . observation VALUES ( 3 , '2020-07-08' , 'trois' , '01010000206A08000018BF3048EA112341183933F6CC885A41' , NULL ); On fait une jointure attributaire entre les points des observations et les communes 1 2 3 4 5 6 7 8 9 10 SELECT -- tous les champs de la table observation o . * , -- le nom de la commune c . nom , -- l'aire enti\u00e8re en hectares ST_area ( c . geom ):: integer / 10000 AS surface_commune FROM z_formation . observation AS o JOIN z_formation . commune AS c ON o . code_insee = c . code_insee WHERE True R\u00e9sultat: id date description geom code_insee nom surface_commune 2 2020-07-08 deux .... 27213 Vexin-sur-Epte 11434 1 2020-07-08 un .... 76618 Petit-Caux 9243 On ne r\u00e9cup\u00e8re ici que 2 lignes alors qu'il y a bien 3 observations dans la table. Pour r\u00e9cup\u00e9rer les 3 lignes, on doit faire une jointure LEFT. On peut utiliser un CASE WHEN pour tester si la commune est trouv\u00e9e sous chaque point 1 2 3 4 5 6 7 8 9 SELECT o . * , c . nom , ST_area ( c . geom ):: integer / 10000 AS surface_commune , CASE WHEN c . code_insee IS NULL THEN 'pas de commune' ELSE 'ok' END AS test_commune FROM z_formation . observation AS o LEFT JOIN z_formation . commune AS c ON o . code_insee = c . code_insee WHERE True R\u00e9sultat id date description geom code_insee nom surface_commune test_commune 2 2020-07-08 deux .... 27213 Vexin-sur-Epte 11434 ok 1 2020-07-08 un .... 76618 Petit-Caux 9243 ok 3 2020-07-08 trois .... Null Null Null pas de commune","title":"Exemple 2: observations et communes"},{"location":"join_data/#les-jointures-spatiales","text":"Le crit\u00e8re de jointure peut \u00eatre une condition spatiale . On r\u00e9alise souvent une jointure par intersection ou par proximit\u00e9 .","title":"Les jointures spatiales"},{"location":"join_data/#joindre-des-points-avec-des-polygones","text":"Un exemple classique de r\u00e9cup\u00e9ration des donn\u00e9es de la table commune (nom, etc.) depuis une table de points. 1 2 3 4 5 6 7 8 9 -- Pour chaque lieu-dit, on veut le nom de la commune SELECT l . id_lieu_dit_habite , l . nom , c . nom AS nom_commune , c . code_insee , l . geom FROM \"z_formation\" . lieu_dit_habite AS l JOIN \"z_formation\" . commune AS c ON st_intersects ( c . geom , l . geom ) ORDER BY l . nom id_lieu_dit_habite nom nom_commune code_insee geom 58 Abbaye du Valasse Gruchet-le-Valasse 76329 .... 1024 Ablemont Bacqueville-en-Caux 76051 .... 1043 Agranville Douvrend 76220 .... 1377 All des Artisans Mesnils-sur-Iton 27198 .... 1801 All\u00e9e des Maronniers Heudebouville 27332 .... 1293 Alliquerville Trouville 76715 .... 507 Alventot Sainte-H\u00e9l\u00e8ne-Bondeville 76587 .... 555 Alvinbuc Veauville-l\u00e8s-Baons 76729 .... 69 Ancien h\u00f4tel de ville Rouen 76540 .... On peut facilement inverser la table principale pour afficher les lignes ordonn\u00e9es par commune. 1 2 3 4 5 6 7 SELECT c . nom , c . code_insee , l . id_lieu_dit_habite , l . nom FROM \"z_formation\" . commune AS c JOIN \"z_formation\" . lieu_dit_habite AS l ON st_intersects ( c . geom , l . geom ) ORDER BY c . nom nom code_insee id_lieu_dit_habite nom Aclou 27001 107 Manoir de la Haule Acquigny 27003 106 Manoir de Becdal Ailly 27005 596 Quaizes Ailly 27005 595 Ingremare Ailly 27005 594 Gruchet Alizay 27008 667 Le Solitaire Ambenay 27009 204 Les Siaules Ambenay 27009 201 Les Renardieres Ambenay 27009 202 Le Culoron On a plusieurs lignes par commune, autant que de lieux-dits pour cette commune. Par contre, comme ce n'est pas une jointure LEFT, on ne trouve que des r\u00e9sultats pour les communes qui ont des lieux-dits. On pourrait aussi faire des statistiques, en regroupant par les champs de la table principale, ici les communes. 1 2 3 4 5 6 7 8 9 10 SELECT c . nom , c . code_insee , count ( l . id_lieu_dit_habite ) AS nb_lieu_dit , c . geom FROM \"z_formation\" . commune AS c JOIN \"z_formation\" . lieu_dit_habite AS l ON st_intersects ( c . geom , l . geom ) GROUP BY c . nom , c . code_insee , c . geom ORDER BY nb_lieu_dit DESC LIMIT 10 nom code_insee nb_lieu_dit geom Heudebouville 27332 61 .... Mesnils-sur-Iton 27198 52 .... Rouen 76540 20 .... Saint-Sa\u00ebns 76648 19 .... Les Grandes-Ventes 76321 19 .... Mesnil-en-Ouche 27049 18 .... Quincampoix 76517 18 ....","title":"Joindre des points avec des polygones"},{"location":"join_data/#joindre-des-lignes-avec-des-polygones","text":"R\u00e9cup\u00e9rer le code commune de chaque chemin, par intersection entre le chemin et la commune .","title":"Joindre des lignes avec des polygones"},{"location":"join_data/#jointure-spatiale-simple-entre-les-geometries-brutes","text":"1 2 3 4 5 6 7 8 9 -- Ici, on peut r\u00e9cup\u00e9rer plusieurs fois le m\u00eame chemin -- s'il passe par plusieurs communes SELECT v . * , c . nom , c . code_insee FROM \"z_formation\" . chemin AS v JOIN \"z_formation\" . commune AS c ON ST_Intersects ( v . geom , c . geom ) ORDER BY id_chemin , nom Cela peut renvoyer plusieurs lignes par chemin, car chaque chemin peut passer par plusieurs communes.","title":"Jointure spatiale simple entre les g\u00e9om\u00e9tries brutes"},{"location":"join_data/#jointure-spatiale-entre-le-centroide-des-chemins-et-la-geometrie-des-communes","text":"On peut utiliser le centro\u00efde de chaque chemin pour avoir un seul objet par chemin comme r\u00e9sultat. 1 2 3 4 5 6 7 8 9 10 11 -- cr\u00e9ation de l'index CREATE INDEX ON z_formation . chemin USING gist ( ST_Centroid ( geom )); -- Jointure spatiale -- On ne veut qu'une seule ligne par chemin -- Donc on fait l'intersection entre le centro\u00efde des chemins (pour avoir un point) et les communes SELECT v . * , c . nom , c . code_insee FROM \"z_formation\" . chemin AS v JOIN \"z_formation\" . commune AS c ON ST_Intersects ( ST_Centroid ( v . geom ), c . geom ) NB: Attention, dans ce cas, l'index spatial sur la g\u00e9om\u00e9trie des chemins n'est pas utilis\u00e9. C'est pour cela que nous avons cr\u00e9\u00e9 un index spatial sur ST_Centroid(geom) pour la table des chemins. A l'inverse, on peut vouloir faire des statistiques pour chaque commune via jointure spatiale. Par exemple le nombre de chemins et le total des longueurs par commune. 1 2 3 4 5 6 7 8 9 10 11 -- A l'inverse, on veut r\u00e9cup\u00e9rer des statistiques par commune -- On veut une ligne par commune, avec des donn\u00e9es sur les voies SELECT c . id_commune , c . nom , c . code_insee , count ( v . id_chemin ) AS nb_chemin , sum ( st_length ( v . geom )) AS somme_longueur_chemins_entiers FROM z_formation . commune AS c JOIN z_formation . chemin AS v ON st_intersects ( c . geom , st_centroid ( v . geom )) GROUP BY c . id_commune , c . nom , c . code_insee ;","title":"Jointure spatiale entre le centro\u00efde des chemins et la g\u00e9om\u00e9trie des communes"},{"location":"join_data/#utilisation-dune-jointure-left-pour-garder-les-communes-sans-chemins","text":"La requ\u00eate pr\u00e9c\u00e9dente ne renvoie pas de lignes pour les communes qui n'ont pas de chemin dont le centro\u00efde est dans une commune. C'est une jointure de type INNER JOIN Si on veut quand m\u00eame r\u00e9cup\u00e9rer ces communes, on fait une jointure LEFT JOIN : pour les lignes sans chemins, les champs li\u00e9s \u00e0 la table des chemins seront mis \u00e0 NULL. 1 2 3 4 5 6 7 8 9 SELECT c . id_commune , c . nom , c . code_insee , count ( v . id_chemin ) AS nb_chemin , sum ( st_length ( v . geom )) AS somme_longueur_chemins_entiers FROM z_formation . commune AS c LEFT JOIN z_formation . chemin AS v ON st_intersects ( c . geom , st_centroid ( v . geom )) GROUP BY c . id_commune , c . nom , c . code_insee ; C'est beaucoup plus long , car la requ\u00eate n'utilise pas d'abord l'intersection, donc l'index spatial des communes, mais fait un parcours de toutes les lignes des communes, puis un calcul d'intersection. Pour acc\u00e9l\u00e9rer la requ\u00eate, on doit cr\u00e9er l'index sur les centro\u00efdes des chemins 1 CREATE INDEX ON z_formation . chemin USING GIST ( ST_Centroid ( geom )) puis la relancer. Dans cet exemple, on passe de 100 secondes \u00e0 1 seconde, gr\u00e2ce \u00e0 ce nouvel index spatial.","title":"Utilisation d'une jointure LEFT pour garder les communes sans chemins"},{"location":"join_data/#affiner-le-resultat-en-decoupant-les-chemins","text":"Dans la requ\u00eate pr\u00e9c\u00e9dente, on calculait la longueur totale de chaque chemin, pas le morceau exacte qui est sur chaque commune . Pour cela, on va utiliser la fonction ST_Intersection . La requ\u00eate va \u00eatre plus co\u00fbteuse, car il faut r\u00e9aliser le d\u00e9coupage des lignes des chemins par les polygones des communes. On va d\u00e9couper exactement les chemins par commune et r\u00e9cup\u00e9rer les informations 1 2 3 4 5 6 7 8 9 10 11 12 13 14 CREATE TABLE z_formation . decoupe_chemin_par_commune AS -- D\u00e9couper les chemins par commune SELECT -- id unique -- infos du chemin l . id AS id_chemin , -- infos de la commune c . nom , c . code_insee , ST_Multi ( st_collectionextract ( ST_Intersection ( c . geom , l . geom ), 2 )):: geometry ( multilinestring , 2154 ) AS geom FROM \"z_formation\" . commune AS c JOIN \"z_formation\" . chemin AS l ON st_intersects ( c . geom , l . geom ) ; CREATE INDEX ON z_formation . decoupe_chemin_par_commune USING GIST ( geom ); NB : Attention \u00e0 ne pas confondre ST_Intersects qui renvoie vrai ou faux, et ST_Intersection qui renvoie la g\u00e9om\u00e9trie issue du d\u00e9coupage d'une g\u00e9om\u00e9trie par une autre.","title":"Affiner le r\u00e9sultat en d\u00e9coupant les chemins"},{"location":"join_data/#joindre-des-polygones-avec-des-polygones","text":"On peut bien s\u00fbr r\u00e9aliser des jointures spatiales entre 2 couches de polygones , et d\u00e9couper les polygones par intersection. Attention, les performances sont forc\u00e9ment moins bonnes qu'avec des points. Trouver l'ensemble des zonages PLU pour les parcelles du Havre. On va r\u00e9cup\u00e9rer plusieurs r\u00e9sultats pour chaque parcelle si plusieurs zonages chevauchent une parcelle. 1 2 3 4 5 6 7 8 -- Jointure spatiale SELECT p . id_parcelle , z . libelle , z . libelong , z . typezone FROM z_formation . parcelle_havre AS p JOIN z_formation . zone_urba AS z ON st_intersects ( z . geom , p . geom ) WHERE True Compter pour chaque parcelle le nombre de zonages en intersection: on veut une seule ligne par parcelle . 1 2 3 4 5 6 7 8 9 SELECT p . id_parcelle , count ( z . libelle ) AS nombre_zonage FROM z_formation . parcelle_havre AS p JOIN z_formation . zone_urba AS z ON st_intersects ( z . geom , p . geom ) WHERE True GROUP BY p . id_parcelle ORDER BY nombre_zonage DESC D\u00e9couper les parcelles par les zonages, et pouvoir calculer les surfaces des zonages, et le pourcentage par rapport \u00e0 la surface de chaque parcelle. On essaye le SQL suivant: 1 2 3 4 5 6 7 8 9 10 SELECT p . id_parcelle , z . libelle , z . libelong , z . typezone , -- d\u00e9couper les g\u00e9om\u00e9tries st_intersection ( z . geom , p . geom ) AS geom FROM z_formation . parcelle_havre AS p JOIN z_formation . zone_urba AS z ON st_intersects ( z . geom , p . geom ) WHERE True ORDER BY p . id_parcelle Il renvoit l'erreur 1 ERREUR: Error performing intersection: TopologyException: Input geom 1 is invalid: Self-intersection at or near point 492016.26000489673 6938870.663846286 at 492016.26000489673 6938870.663846286 On a ici des soucis de validit\u00e9 de g\u00e9om\u00e9trie . Il nous faut donc corriger les g\u00e9om\u00e9tries avant de poursuivre. Voir chapitre sur la validation des g\u00e9om\u00e9tries. Une fois les g\u00e9om\u00e9tries valid\u00e9es, la requ\u00eate fonctionne. On l'utilise dans une sous-requ\u00eate pour cr\u00e9er une table et calculer les surfaces 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 -- suppression de la table DROP TABLE IF EXISTS z_formation . decoupe_zonage_parcelle ; -- cr\u00e9ation de la table avec calcul de pourcentage de surface CREATE TABLE z_formation . decoupe_zonage_parcelle AS SELECT row_number () OVER () AS id , source . * , ST_Area ( geom ) AS aire , 100 * ST_Area ( geom ) / aire_parcelle AS pourcentage FROM ( SELECT p . id_parcelle , p . id AS idpar , ST_Area ( p . geom ) AS aire_parcelle , z . id_zone_urba , z . libelle , z . libelong , z . typezone , -- d\u00e9couper les g\u00e9om\u00e9tries ( ST_Multi ( st_intersection ( z . geom , p . geom ))):: geometry ( MultiPolygon , 2154 ) AS geom FROM z_formation . parcelle_havre AS p JOIN z_formation . zone_urba AS z ON st_intersects ( z . geom , p . geom ) WHERE True ) AS source ; -- Ajout de la cl\u00e9 primaire ALTER TABLE z_formation . decoupe_zonage_parcelle ADD PRIMARY KEY ( id ); -- Ajout de l'index spatial CREATE INDEX ON z_formation . decoupe_zonage_parcelle USING GIST ( geom );","title":"Joindre des polygones avec des polygones"},{"location":"join_data/#faire-un-rapport-des-surfaces-intersectees-de-zonages-sur-une-table-principale","text":"Par exemple, pour chacune des communes, on souhaite calculer la somme des surfaces intersect\u00e9e par chaque type de zone (parcs, znieff, etc.). Afin d'avoir \u00e0 disposition des donn\u00e9es de test pour cet exemple de rapport, nous allons cr\u00e9er 2 tables z_formation.parc_national et z_formation.znieff , et y ins\u00e9rer des fausses donn\u00e9es: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 -- Table des parcs nationaux CREATE TABLE IF NOT EXISTS z_formation . parc_national ( id serial primary key , nom text , geom geometry ( multipolygon , 2154 ) ); CREATE INDEX ON z_formation . parc_national USING GIST ( geom ); -- Table des znieff CREATE TABLE IF NOT EXISTS z_formation . znieff ( id serial primary key , nom_znieff text , geom geometry ( multipolygon , 2154 ) ); CREATE INDEX ON z_formation . znieff USING GIST ( geom ); On ins\u00e8re des polygones dans ces deux tables: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 -- donn\u00e9es de test -- parcs INSERT INTO z_formation . parc_national VALUES ( 1 , 'un' , '01060000206A0800000100000001030000000100000008000000C3F7DE73553D20411B3DC1FB0C625A410531F757E93D2041BAECB21FA85E5A41F35B09978081204195F05B9787595A41D61E4865A1A7204147BC8A3AC0605A41ED76A806317F2041A79F7E4876605A41B80752433C832041037846623A655A41E10ED595BA6120413CC1D1C18C685A41C3F7DE73553D20411B3DC1FB0C625A41' ); INSERT INTO z_formation . parc_national VALUES ( 2 , 'deux' , '01060000206A080000010000000103000000010000000900000024D68B4AE0412141AAAAAA3C685B5A4130642ACBD01421413A85AE4B72585A41CA08F0240E382141746C4BD107535A41FA30F7A78A4A2141524A29E544555A414796BF5CE63621414DD2E222A4565A416B92160F9B5D2141302807F981575A4130DC700B2E782141DC0ED50B6B5C5A4106FBB8C8294F214150AC17BF015E5A4124D68B4AE0412141AAAAAA3C685B5A41' ); INSERT INTO z_formation . parc_national VALUES ( 3 , 'trois' , '01060000206A0800000100000001030000000100000006000000918DCFE7E0861F4137AB79AF14515A411AE56040588A1F41642A43EEC74F5A41DF2EBB3CEBA41F418C31C66ADA4F5A4168864C9562A81F416E87EA40B8505A415CBC8A74C3A31F410FA4F63202515A41918DCFE7E0861F4137AB79AF14515A41' ); INSERT INTO z_formation . parc_national VALUES ( 4 , 'quatre' , '01060000206A080000010000000103000000010000000500000004474FE81DBA2041269A684EFD625A41AB17C51223C9204120B507BEAD605A4116329539BBF22041A3273886D5615A416F611F0FB6E32041FA1A9F0F4A645A4104474FE81DBA2041269A684EFD625A41' ); INSERT INTO z_formation . parc_national VALUES ( 5 , 'cinq' , '01060000206A0800000100000001030000000100000005000000F2E3C256231E2041E0ACE631AE535A41F7C823E772202041E89C73B6EF505A41B048BCC266362041DAC785A15E515A419E999911782F204180C9F223F8535A41F2E3C256231E2041E0ACE631AE535A41' ); SELECT pg_catalog . setval ( 'z_formation.parc_national_id_seq' , 5 , true ); -- znieff INSERT INTO z_formation . znieff VALUES ( 1 , 'uno' , '01060000206A08000001000000010300000001000000050000004039188C39D12041770A5DF74A4A5A413A54B7FBE9CE20410C5DA7C8F5455A41811042C0A4EA204130ECE38267475A416F611F0FB6E320417125FC66FB475A414039188C39D12041770A5DF74A4A5A41' ); INSERT INTO z_formation . znieff VALUES ( 2 , 'dos' , '01060000206A080000010000000103000000010000000500000076BEC6DF62492141513FFDF0525A5A417CA32770B24B21411EDBD22150595A419437ABB1F05421410F06E50CBF595A419437ABB1F0542141B022F1FE085A5A4176BEC6DF62492141513FFDF0525A5A41' ); INSERT INTO z_formation . znieff VALUES ( 3 , 'tres' , '01060000206A0800000100000001030000000100000005000000A6E6CD62DF5B2141B607528F585C5A41ACCB2EF32E5E2141C5DC3FA4E95B5A414CB7438DE46A2141C5DC3FA4E95B5A41B895F013CE62214189888850A55D5A41A6E6CD62DF5B2141B607528F585C5A41' ); INSERT INTO z_formation . znieff VALUES ( 4 , 'quatro' , '01060000206A0800000100000001030000000100000005000000CE857DF445102041985D7665365D5A41DA4F3F15E5142041339521C7305B5A41C2F7DE73553D2041927815D5E65A5A410393E50712252041B607528F585C5A41CE857DF445102041985D7665365D5A41' ); INSERT INTO z_formation . znieff VALUES ( 5 , 'cinco' , '01060000206A080000010000000103000000010000000500000045A632DC2B702041FD25CB033C5F5A41CEFDC334A373204115EB459D0E5C5A41F25B099780812041397A8257805D5A415755558D1A7720419E42D7F5855F5A4145A632DC2B702041FD25CB033C5F5A41' ); SELECT pg_catalog . setval ( 'z_formation.znieff_id_seq' , 5 , true ); Pour chaque commune, on souhaite calculer la somme des surfaces intersect\u00e9es par chaque type de zone. On doit donc utiliser toutes les tables de zonage (ici seulement 2 tables, mais c'est possible d'en ajouter) R\u00e9sultat attendu: id_commune code_insee nom surface_commune_ha somme_surface_parcs somme_surface_znieff 1139 27042 Barville 275.138028733401 87.2237204013011 None 410 27057 Bernienville 779.74546553394 None 5.26504189468878 1193 27061 Berthouville 757.19696570046 19.9975421896336 None 495 27074 Boisney 576.995877227961 0.107059260396721 None 432 27077 Boissey-le-Ch\u00e2tel 438.373848703835 434.510197417769 83.9289621127432 M\u00e9thode avec des sous-requ\u00eates 1 2 3 4 5 6 7 SELECT c . id_commune , c . code_insee , c . nom , ST_Area ( c . geom ) / 10000 AS surface_commune_ha , ( SELECT sum ( ST_Area ( ST_Intersection ( c . geom , p . geom )) / 10000 ) FROM z_formation . parc_national AS p WHERE ST_Intersects ( p . geom , c . geom ) ) AS surface_parc_national , ( SELECT sum ( ST_Area ( ST_Intersection ( c . geom , p . geom )) / 10000 ) FROM z_formation . znieff AS p WHERE ST_Intersects ( p . geom , c . geom ) ) AS surface_znieff FROM z_formation . commune AS c ORDER BY c . nom M\u00e9thode avec des jointures LEFT 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 SELECT -- champs choisis dans la table commune c . id_commune , c . code_insee , c . nom , -- surface en ha ST_Area ( c . geom ) / 10000 AS surface_commune_ha , -- somme des d\u00e9coupages des parcs par commune sum ( ST_Area ( ST_Intersection ( c . geom , p . geom )) / 10000 ) AS somme_surface_parcs , -- somme des d\u00e9coupages des znieff par commune sum ( ST_Area ( ST_Intersection ( c . geom , z . geom )) / 10000 ) AS somme_surface_znieff FROM z_formation . commune AS c -- jointure spatiale sur les parcs LEFT JOIN z_formation . parc_national AS p ON ST_Intersects ( c . geom , p . geom ) -- jointure spatiale sur les znieff LEFT JOIN z_formation . znieff AS z ON ST_Intersects ( c . geom , z . geom ) -- clause WHERE optionelle -- WHERE p.id IS NOT NULL OR z.id IS NOT NULL -- on regroupe sur les champs des communes GROUP BY c . id_commune , c . code_insee , c . nom -- on ordonne par nom ORDER BY c . nom Avantages : on peut int\u00e9grer facilement dans la clause WHERE des conditions sur les champs des tables jointes. Par exemple ne r\u00e9cup\u00e9rer que les lignes qui sont concern\u00e9es par un parc ou une znieff, via WHERE p.id IS NOT NULL OR z.id IS NOT NULL (comment\u00e9 ci-dessus pour le d\u00e9sactiver) On peut sortir plusieurs aggr\u00e9gats pour les tables jointes. Par exemple un d\u00e9compte des parcs, un d\u00e9compte des znieff ATTENTION: on peut avoir des doublons qui vont cr\u00e9er des erreurs. Voir cet exemple: http://sqlfiddle.com/#!17/73485c/2/0 cette m\u00e9thode peut poser des soucis de performance ATTENTION : il faut absolument avoir un index spatial sur le champ geom de toutes les tables le calcul de d\u00e9coupage des polygones des communes par ceux des zonages peut \u00eatre tr\u00e8s long (et l'index spatial ne sert \u00e0 rien ici)","title":"Faire un rapport des surfaces intersect\u00e9es de zonages sur une table principale"},{"location":"join_data/#distances-et-tampons-entre-couches","text":"Pour chaque objets d'une table, on souhaite r\u00e9cup\u00e9rer des informations sur les objets proches d'une autre table . Au lieu d'utiliser un tampon puis une intersection, on utilise la fonction ST_DWithin On prend comme exemple la table des bornes \u00e0 incendie cr\u00e9\u00e9e pr\u00e9c\u00e9demment (remplie avec quelques donn\u00e9es de test). Trouver toutes les parcelles \u00e0 moins de 200m d'une borne \u00e0 incendie 1 2 3 4 5 6 7 8 SELECT p . id_parcelle , p . geom , b . id_borne , b . code , ST_Distance ( b . geom , p . geom ) AS distance FROM z_formation . parcelle_havre AS p JOIN z_formation . borne_incendie AS b ON ST_DWithin ( p . geom , b . geom , 200 ) ORDER BY id_parcelle , id_borne Attention, elle peut renvoyer plusieurs fois la m\u00eame parcelle si 2 bornes sont assez proches. Pour ne r\u00e9cup\u00e9rer que la borne la plus proche, on peut faire la requ\u00eate suivante. La clause DISTINCT ON permet de dire quel champ doit \u00eatre unique (ici id_parcelle). On ordonne ensuite par ce champ et par la distance pour prendre seulement la ligne correspondant \u00e0 la parcelle la plus proche 1 2 3 4 5 6 7 8 SELECT DISTINCT ON ( p . id_parcelle ) p . id_parcelle , p . geom , b . id_borne , b . code , ST_Distance ( b . geom , p . geom ) AS distance FROM z_formation . parcelle_havre AS p JOIN z_formation . borne_incendie AS b ON ST_DWithin ( p . geom , b . geom , 200 ) ORDER BY id_parcelle , distance Pour information, on peut v\u00e9rifier en cr\u00e9ant les tampons 1 2 3 4 5 6 7 -- Tampons non dissous SELECT id_borne , ST_Buffer ( geom , 200 ) AS geom FROM z_formation . borne_incendie -- Tampons dissous SELECT ST_Union ( ST_Buffer ( geom , 200 )) AS geom FROM z_formation . borne_incendie Un article int\u00e9ressant de Paul Ramsey sur le calcul de distance via l'op\u00e9rateur <-> pour trouver le plus proche voisin d'un objet. Continuer vers Fusionner des g\u00e9om\u00e9tries","title":"Distances et tampons entre couches"},{"location":"links_and_data/","text":"Liens utiles # Documentation # Documentation de PostgreSQL : https://docs.postgresql.fr/current/ Documentation des fonctions PostGIS: en anglais : https://postgis.net/docs/reference.html en fran\u00e7ais https://postgis.net/docs/manual-2.4/postgis-fr.html notamment la r\u00e9f\u00e9rence des fonctions spatiales : https://postgis.net/docs/manual-2.4/postgis-fr.html#reference Base de donn\u00e9es # Nous pr\u00e9supposons qu'une base de donn\u00e9es est accessible pour la formation, via un utilisateur PostgreSQL avec des droits \u00e9lev\u00e9s (notamment pour cr\u00e9er des sch\u00e9mas et des tables). L'extension PostGIS doit aussi \u00eatre activ\u00e9e sur cette base de donn\u00e9es. Jeux de donn\u00e9es # Pour cette formation, nous utilisons des donn\u00e9es libres de droit: Un zip est t\u00e9l\u00e9chargable en cliquant sur ce lien . Ce jeu de donn\u00e9es a pour sources : Extraction de donn\u00e9es d' OpenStreetMap dans un format SIG, sous licence ODBL ( site https://github.com/igeofr/osm2igeo ). On utilisera par exemple les donn\u00e9es de l'ancienne r\u00e9gion Haute-Normandie: https://www.data.data-wax.com/OSM2IGEO/FRANCE/202103_OSM2IGEO_23_HAUTE_NORMANDIE_SHP_L93_2154.zip Donn\u00e9es cadastrales (site https://cadastre.data.gouv.fr ), sous licence Par exemple pour la Seine-Maritime: https://cadastre.data.gouv.fr/data/etalab-cadastre/2019-01-01/shp/departements/76/ PLU (site https://www.geoportail-z_formation.gouv.fr/map/ ). Par exemple les donn\u00e9es de la ville du Havre: https://www.geoportail-z_formation.gouv.fr/map/#tile=1&lon=0.13496041707835396&lat=49.49246433172931&zoom=12&mlon=0.117760&mlat=49.502918 Cliquer sur la commune, et utiliser le lien de t\u00e9l\u00e9chargement, actuellement: Ces donn\u00e9es seront import\u00e9es dans la base de formation via les outils de QGIS. Concepts de base de donn\u00e9es: # Un rappel sur les concepts de table, champs, relations. Documentation de QGIS : https://docs.qgis.org/latest/fr/docs/training_manual/database_concepts/index.html Quelques extensions QGIS # Lire la formation QGIS \u00e9galement Autosaver : sauvegarde automatique du projet QGIS toutes les N minutes Layer Board : liste l'ensemble des couches du projet et permet de modifier des caract\u00e9ristiques pour plusieurs couches \u00e0 la fois Cadastre : import et exploitation des donn\u00e9es EDIGEO ET MAJIC dans PostgreSQL Continuer vers Gestion des donn\u00e9es PostgreSQL dans QGIS","title":"Liens et donn\u00e9es"},{"location":"links_and_data/#liens-utiles","text":"","title":"Liens utiles"},{"location":"links_and_data/#documentation","text":"Documentation de PostgreSQL : https://docs.postgresql.fr/current/ Documentation des fonctions PostGIS: en anglais : https://postgis.net/docs/reference.html en fran\u00e7ais https://postgis.net/docs/manual-2.4/postgis-fr.html notamment la r\u00e9f\u00e9rence des fonctions spatiales : https://postgis.net/docs/manual-2.4/postgis-fr.html#reference","title":"Documentation"},{"location":"links_and_data/#base-de-donnees","text":"Nous pr\u00e9supposons qu'une base de donn\u00e9es est accessible pour la formation, via un utilisateur PostgreSQL avec des droits \u00e9lev\u00e9s (notamment pour cr\u00e9er des sch\u00e9mas et des tables). L'extension PostGIS doit aussi \u00eatre activ\u00e9e sur cette base de donn\u00e9es.","title":"Base de donn\u00e9es"},{"location":"links_and_data/#jeux-de-donnees","text":"Pour cette formation, nous utilisons des donn\u00e9es libres de droit: Un zip est t\u00e9l\u00e9chargable en cliquant sur ce lien . Ce jeu de donn\u00e9es a pour sources : Extraction de donn\u00e9es d' OpenStreetMap dans un format SIG, sous licence ODBL ( site https://github.com/igeofr/osm2igeo ). On utilisera par exemple les donn\u00e9es de l'ancienne r\u00e9gion Haute-Normandie: https://www.data.data-wax.com/OSM2IGEO/FRANCE/202103_OSM2IGEO_23_HAUTE_NORMANDIE_SHP_L93_2154.zip Donn\u00e9es cadastrales (site https://cadastre.data.gouv.fr ), sous licence Par exemple pour la Seine-Maritime: https://cadastre.data.gouv.fr/data/etalab-cadastre/2019-01-01/shp/departements/76/ PLU (site https://www.geoportail-z_formation.gouv.fr/map/ ). Par exemple les donn\u00e9es de la ville du Havre: https://www.geoportail-z_formation.gouv.fr/map/#tile=1&lon=0.13496041707835396&lat=49.49246433172931&zoom=12&mlon=0.117760&mlat=49.502918 Cliquer sur la commune, et utiliser le lien de t\u00e9l\u00e9chargement, actuellement: Ces donn\u00e9es seront import\u00e9es dans la base de formation via les outils de QGIS.","title":"Jeux de donn\u00e9es"},{"location":"links_and_data/#concepts-de-base-de-donnees","text":"Un rappel sur les concepts de table, champs, relations. Documentation de QGIS : https://docs.qgis.org/latest/fr/docs/training_manual/database_concepts/index.html","title":"Concepts de base de donn\u00e9es:"},{"location":"links_and_data/#quelques-extensions-qgis","text":"Lire la formation QGIS \u00e9galement Autosaver : sauvegarde automatique du projet QGIS toutes les N minutes Layer Board : liste l'ensemble des couches du projet et permet de modifier des caract\u00e9ristiques pour plusieurs couches \u00e0 la fois Cadastre : import et exploitation des donn\u00e9es EDIGEO ET MAJIC dans PostgreSQL Continuer vers Gestion des donn\u00e9es PostgreSQL dans QGIS","title":"Quelques extensions QGIS"},{"location":"merge_geometries/","text":"Fusionner des g\u00e9om\u00e9tries # On souhaite cr\u00e9er une seule g\u00e9om\u00e9trie qui est issue de la fusion de toutes les g\u00e9om\u00e9tries regroup\u00e9es par un crit\u00e8re (nature, code, etc.) Par exemple un polygone fusionnant les zonages qui partagent le m\u00eame type 1 2 3 4 SELECT count ( id_zone_urba ) AS nb_objets , typezone , ST_Union ( geom ) AS geom FROM z_formation . zone_urba GROUP BY typezone On souhaite parfois fusionner toutes les g\u00e9om\u00e9tries qui sont jointives . Par exemple, on veut fusionner toutes les parcelles jointives pour cr\u00e9er des blocs. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 DROP TABLE IF EXISTS z_formation . bloc_parcelle_havre ; CREATE TABLE z_formation . bloc_parcelle_havre AS SELECT row_number () OVER () AS id , string_agg ( id :: text , ', ' ) AS ids , t . geom :: geometry ( polygon , 2154 ) AS geom FROM ( SELECT ( St_Dump ( ST_Union ( a . geom ))). geom AS geom FROM z_formation . parcelle_havre AS a WHERE ST_IsValid ( a . geom ) ) t JOIN z_formation . parcelle_havre AS p ON ST_Intersects ( p . geom , t . geom ) GROUP BY t . geom ; ALTER TABLE z_formation . bloc_parcelle_havre ADD PRIMARY KEY ( id ); CREATE INDEX ON z_formation . bloc_parcelle_havre USING GIST ( geom ); Continuer vers Les triggers","title":"Fusionner"},{"location":"merge_geometries/#fusionner-des-geometries","text":"On souhaite cr\u00e9er une seule g\u00e9om\u00e9trie qui est issue de la fusion de toutes les g\u00e9om\u00e9tries regroup\u00e9es par un crit\u00e8re (nature, code, etc.) Par exemple un polygone fusionnant les zonages qui partagent le m\u00eame type 1 2 3 4 SELECT count ( id_zone_urba ) AS nb_objets , typezone , ST_Union ( geom ) AS geom FROM z_formation . zone_urba GROUP BY typezone On souhaite parfois fusionner toutes les g\u00e9om\u00e9tries qui sont jointives . Par exemple, on veut fusionner toutes les parcelles jointives pour cr\u00e9er des blocs. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 DROP TABLE IF EXISTS z_formation . bloc_parcelle_havre ; CREATE TABLE z_formation . bloc_parcelle_havre AS SELECT row_number () OVER () AS id , string_agg ( id :: text , ', ' ) AS ids , t . geom :: geometry ( polygon , 2154 ) AS geom FROM ( SELECT ( St_Dump ( ST_Union ( a . geom ))). geom AS geom FROM z_formation . parcelle_havre AS a WHERE ST_IsValid ( a . geom ) ) t JOIN z_formation . parcelle_havre AS p ON ST_Intersects ( p . geom , t . geom ) GROUP BY t . geom ; ALTER TABLE z_formation . bloc_parcelle_havre ADD PRIMARY KEY ( id ); CREATE INDEX ON z_formation . bloc_parcelle_havre USING GIST ( geom ); Continuer vers Les triggers","title":"Fusionner des g\u00e9om\u00e9tries"},{"location":"perform_calculation/","text":"Faire des calculs # Calcul sur des attributs # Le SQL permet de r\u00e9aliser des calculs ou des modifications \u00e0 partir de champs. On peut donc faire des calculs sur des nombres, ou des modifications (remplacement de texte, mise en majuscule, etc.) Faire un calcul tr\u00e8s simple, ave des op\u00e9rateurs + - / et *, ainsi que des parenth\u00e8ses 1 2 3 4 -- On multiplie 10 par 2 SELECT 10 * 2 AS vingt , ( 2 . 5 - 1 ) * 10 AS quinze Il est aussi possible de faire des calculs \u00e0 partir d'un ou plusieurs champs. Nous souhaitons par exemple cr\u00e9er un champ qui contiendra la population des communes. Dans la donn\u00e9e source, le champ popul est de type cha\u00eene de caract\u00e8re, car il contient parfois la valeur 'NC' lorsque la population n'est pas connue. Nous ne pouvons pas faire de calculs \u00e0 partir d'un champ texte. On souhaite donc cr\u00e9er un nouveau champ population pour y stocker les valeurs enti\u00e8res. 1 2 -- Ajout d'un champ de type entier dans la table ALTER TABLE z_formation . commune ADD COLUMN population integer ; Modifier le nouveau champ population pour y mettre la valeur enti\u00e8re lorsqu'elle est connue. La modification d'une table se fait avec la requ\u00eate UPDATE , en passant les champs \u00e0 modifier et leur nouvelle valeur via SET 1 2 3 4 5 6 7 -- Mise \u00e0 jour d'un champ \u00e0 partir d'un calcul UPDATE z_formation . commune SET population = CASE WHEN popul != 'NC' THEN popul :: integer ELSE NULL END ; Dans cette requ\u00eate, le CASE WHEN condition THEN valeur ELSE autre_valeur END permet de faire un test sur la valeur d'origine, et de proposer une valeur si la condition est remplie ( https://sql.sh/cours/case ) Une fois ce champ population renseign\u00e9 correctement, dans un type entier, on peut r\u00e9aliser un calcul tr\u00e8s simple, par exemple doubler la population : 1 2 3 4 5 6 -- Calcul simple : on peut utiliser les op\u00e9rateurs math\u00e9matiques SELECT id_commune , code_insee , nom , geom , population , population * 2 AS double_population FROM z_formation . commune LIMIT 10 Il est possible de combiner plusieurs champs pour r\u00e9aliser un calcul. Nous verrons plus loin comment calculer la densit\u00e9 de population \u00e0 partir de la population et de la surface des communes. Calculer des caract\u00e9ristiques spatiales # Par exemple la longueur ou la surface Calculer la longueur d'objets lin\u00e9aires 1 2 3 4 5 -- Calcul des longueurs de route SELECT id_route , id , nature , ST_Length ( geom ) AS longueur_m FROM z_formation . route LIMIT 100 Calculer la surface de polygones, et utiliser ce r\u00e9sultat dans un calcul. Par exemple ici la densit\u00e9 de population : 1 2 3 4 5 6 7 -- Calculer des donn\u00e9es \u00e0 partir de champs et de fonctions spatiales SELECT id_commune , code_insee , nom , geom , population , ST_Area ( geom ) AS surface , population / ( ST_Area ( geom ) / 1000000 ) AS densite_hab_km FROM z_formation . commune LIMIT 10 Cr\u00e9er des g\u00e9om\u00e9tries \u00e0 partir de g\u00e9om\u00e9tries # On peut modifier les g\u00e9om\u00e9tries avec des fonctions spatiales, ce qui revient \u00e0 effectuer un calcul sur les g\u00e9om\u00e9tries. Deux exemples classiques : centroides et tampons Calculer le centro\u00efde de polygones 1 2 3 4 -- Centroides des communes SELECT id_commune , code_insee , nom , ST_Centroid ( geom ) AS geom FROM z_formation . commune Le centro\u00efde peut ne pas \u00eatre \u00e0 l'int\u00e9rieur du polygone, par exemple sur la commune de Arni\u00e8res-sur-Iton . Forcer le centro\u00efde \u00e0 l'int\u00e9rieur du polygone . Attention, ce calcul est plus long. Si vous souhaitez mieux comprendre l'algorithme derri\u00e8re cette fonction 1 2 3 4 5 -- Centroides \u00e0 l'int\u00e9rieur des communes -- Attention, c'est plus long \u00e0 calculer SELECT id_commune , code_insee , nom , ST_PointOnSurface ( geom ) AS geom FROM z_formation . commune Calculer le tampon autour d'objets 1 2 3 4 5 -- Tampons de 1km autour des communes SELECT id_commune , nom , population , ST_Buffer ( geom , 1000 ) AS geom FROM z_formation . commune LIMIT 10 Continuer vers Filtrer des donn\u00e9es: WHERE","title":"Calcul & Fonctions"},{"location":"perform_calculation/#faire-des-calculs","text":"","title":"Faire des calculs"},{"location":"perform_calculation/#calcul-sur-des-attributs","text":"Le SQL permet de r\u00e9aliser des calculs ou des modifications \u00e0 partir de champs. On peut donc faire des calculs sur des nombres, ou des modifications (remplacement de texte, mise en majuscule, etc.) Faire un calcul tr\u00e8s simple, ave des op\u00e9rateurs + - / et *, ainsi que des parenth\u00e8ses 1 2 3 4 -- On multiplie 10 par 2 SELECT 10 * 2 AS vingt , ( 2 . 5 - 1 ) * 10 AS quinze Il est aussi possible de faire des calculs \u00e0 partir d'un ou plusieurs champs. Nous souhaitons par exemple cr\u00e9er un champ qui contiendra la population des communes. Dans la donn\u00e9e source, le champ popul est de type cha\u00eene de caract\u00e8re, car il contient parfois la valeur 'NC' lorsque la population n'est pas connue. Nous ne pouvons pas faire de calculs \u00e0 partir d'un champ texte. On souhaite donc cr\u00e9er un nouveau champ population pour y stocker les valeurs enti\u00e8res. 1 2 -- Ajout d'un champ de type entier dans la table ALTER TABLE z_formation . commune ADD COLUMN population integer ; Modifier le nouveau champ population pour y mettre la valeur enti\u00e8re lorsqu'elle est connue. La modification d'une table se fait avec la requ\u00eate UPDATE , en passant les champs \u00e0 modifier et leur nouvelle valeur via SET 1 2 3 4 5 6 7 -- Mise \u00e0 jour d'un champ \u00e0 partir d'un calcul UPDATE z_formation . commune SET population = CASE WHEN popul != 'NC' THEN popul :: integer ELSE NULL END ; Dans cette requ\u00eate, le CASE WHEN condition THEN valeur ELSE autre_valeur END permet de faire un test sur la valeur d'origine, et de proposer une valeur si la condition est remplie ( https://sql.sh/cours/case ) Une fois ce champ population renseign\u00e9 correctement, dans un type entier, on peut r\u00e9aliser un calcul tr\u00e8s simple, par exemple doubler la population : 1 2 3 4 5 6 -- Calcul simple : on peut utiliser les op\u00e9rateurs math\u00e9matiques SELECT id_commune , code_insee , nom , geom , population , population * 2 AS double_population FROM z_formation . commune LIMIT 10 Il est possible de combiner plusieurs champs pour r\u00e9aliser un calcul. Nous verrons plus loin comment calculer la densit\u00e9 de population \u00e0 partir de la population et de la surface des communes.","title":"Calcul sur des attributs"},{"location":"perform_calculation/#calculer-des-caracteristiques-spatiales","text":"Par exemple la longueur ou la surface Calculer la longueur d'objets lin\u00e9aires 1 2 3 4 5 -- Calcul des longueurs de route SELECT id_route , id , nature , ST_Length ( geom ) AS longueur_m FROM z_formation . route LIMIT 100 Calculer la surface de polygones, et utiliser ce r\u00e9sultat dans un calcul. Par exemple ici la densit\u00e9 de population : 1 2 3 4 5 6 7 -- Calculer des donn\u00e9es \u00e0 partir de champs et de fonctions spatiales SELECT id_commune , code_insee , nom , geom , population , ST_Area ( geom ) AS surface , population / ( ST_Area ( geom ) / 1000000 ) AS densite_hab_km FROM z_formation . commune LIMIT 10","title":"Calculer des caract\u00e9ristiques spatiales"},{"location":"perform_calculation/#creer-des-geometries-a-partir-de-geometries","text":"On peut modifier les g\u00e9om\u00e9tries avec des fonctions spatiales, ce qui revient \u00e0 effectuer un calcul sur les g\u00e9om\u00e9tries. Deux exemples classiques : centroides et tampons Calculer le centro\u00efde de polygones 1 2 3 4 -- Centroides des communes SELECT id_commune , code_insee , nom , ST_Centroid ( geom ) AS geom FROM z_formation . commune Le centro\u00efde peut ne pas \u00eatre \u00e0 l'int\u00e9rieur du polygone, par exemple sur la commune de Arni\u00e8res-sur-Iton . Forcer le centro\u00efde \u00e0 l'int\u00e9rieur du polygone . Attention, ce calcul est plus long. Si vous souhaitez mieux comprendre l'algorithme derri\u00e8re cette fonction 1 2 3 4 5 -- Centroides \u00e0 l'int\u00e9rieur des communes -- Attention, c'est plus long \u00e0 calculer SELECT id_commune , code_insee , nom , ST_PointOnSurface ( geom ) AS geom FROM z_formation . commune Calculer le tampon autour d'objets 1 2 3 4 5 -- Tampons de 1km autour des communes SELECT id_commune , nom , population , ST_Buffer ( geom , 1000 ) AS geom FROM z_formation . commune LIMIT 10 Continuer vers Filtrer des donn\u00e9es: WHERE","title":"Cr\u00e9er des g\u00e9om\u00e9tries \u00e0 partir de g\u00e9om\u00e9tries"},{"location":"postgresql_in_qgis/","text":"Gestion des donn\u00e9es PostgreSQL dans QGIS # Introduction # Lorsqu'on travaille avec des donn\u00e9es PostgreSQL , QGIS n'acc\u00e8de pas \u00e0 la donn\u00e9e en lisant un ou plusieurs fichiers, mais fait des requ\u00eates \u00e0 la base, \u00e0 chaque fois qu'il en a besoin: d\u00e9placement de carte, zoom, ouverture de la table attributaire, s\u00e9lection par expression, etc. QGIS se connecte \u00e0 la base de donn\u00e9es, et r\u00e9cup\u00e8re des donn\u00e9es qui sont stock\u00e9es dans des tables. Il doit donc t\u00e9l\u00e9charger la donn\u00e9e \u00e0 chaque action (pas de cache car la donn\u00e9e peut changer entre temps). une table \u00e9quivaut \u00e0 une couche SIG, d\u00e9finie par un nom, une liste de champs typ\u00e9s, et un ou plusieurs champs de g\u00e9om\u00e9trie. une g\u00e9om\u00e9trie est caract\u00e9ris\u00e9e par un type (polygone, point, ligne, etc.), une dimension (2D ou 3D) et une projection (Ex: EPSG:2154) codifi\u00e9e via un SRID ( Ex: 2154) certaines tables n'ont pas de g\u00e9om\u00e9trie: on les appelle alors non spatiales. QGIS sait les exploiter, ce qui permet de stocker des informations de contexte (nomenclature, \u00e9v\u00e9nements). La base de donn\u00e9es fournit donc un lieu de stockage des donn\u00e9es centralis\u00e9. On peut g\u00e9rer les droits d'acc\u00e8s ou d'\u00e9criture sur les sch\u00e9mas et les tables. Cr\u00e9er une connexion QGIS \u00e0 la base de donn\u00e9es # Dans QGIS, il faut cr\u00e9er une nouvelle connexion \u00e0 PostgreSQL, via l'outil \"El\u00e9phant\" : menu Couches / Ajouter une couche / Ajouter une couche PostgreSQL . Configurer les options suivantes: laisser le champ Service vide cocher les cases Enregistrer \u00e0 c\u00f4t\u00e9 de l'utilisateur et du mot de passe, apr\u00e8s avoir Tester la connexion (via le bouton d\u00e9di\u00e9) cocher la case en bas Utiliser la table de m\u00e9tadonn\u00e9es estim\u00e9es Valider Attention Pour plus de s\u00e9curit\u00e9, privil\u00e9gier l'usage d'un service PostgreSQL: https://docs.qgis.org/latest/fr/docs/user_manual/managing_data_source/opening_data.html#pg-service-file Il est aussi int\u00e9ressant pour les performances d'acc\u00e8s aux donn\u00e9es PostgreSQL de modifier une option dans les options de QGIS, onglet Rendu : il faut cocher la case R\u00e9aliser la simplification par le fournisseur de donn\u00e9es lorsque c'est possible . Cela permet de t\u00e9l\u00e9charger des versions all\u00e9g\u00e9es des donn\u00e9es aux petites \u00e9chelles. Documentation NB Pour les couches PostGIS qui auraient d\u00e9j\u00e0 \u00e9t\u00e9 ajout\u00e9es avant d'avoir activ\u00e9 cette option, vous pouvez manuellement changer dans vos projets via l'onglet Rendu de la bo\u00eete de dialogue des propri\u00e9t\u00e9s de chaque couche PostGIS. Ouvrir une couche PostgreSQL dans QGIS # Trois solutions sont possibles: utiliser l'explorateur : seulement pour les tables spatiales, sauf si on a coch\u00e9 Lister les tables sans g\u00e9om\u00e9tries dans les propri\u00e9t\u00e9s de la connexion. Le panneau pr\u00e9sente un arbre qui liste les sch\u00e9mas, puis les tables ou vues exploitables. Une ic\u00f4ne devant chaque table/vue indique si une table est g\u00e9om\u00e9trique ou non ainsi que le type de g\u00e9om\u00e9trie, point, ligne ou polyg\u00f4ne. utiliser le menu Couche / Ajouter une couche . La boite de dialogue propose de se connecter, puis liste les sch\u00e9mas et les tables utiliser le Gestionnaire de base de donn\u00e9es , qui pr\u00e9sente une fen\u00eatre QGIS s\u00e9par\u00e9e d\u00e9di\u00e9e aux manipulations sur les donn\u00e9es. Le Gestionnaire de base de donn\u00e9es # On travaille via QGIS, avec le gestionnaire de bases de donn\u00e9es : menu Base de donn\u00e9es > Gestionnaire BD (sinon via l'ic\u00f4ne de la barre d\u2019outil base de donn\u00e9es). Dans l'arbre qui se pr\u00e9sente \u00e0 gauche du gestionnaire de bdd, on peut choisir sa connexion , puis double-cliquer, ce qui montre l'ensemble des sch\u00e9mas , et l'ouverture d'un sch\u00e9ma montre la liste des tables et vues. Les menus du gestionnaire permettent de cr\u00e9er ou d'\u00e9diter des objets (sch\u00e9mas, tables). Une fen\u00eatre SQL permet de lancer manuellement des requ\u00eates SQL. Nous allons principalement utiliser cet outil : menu Base de donn\u00e9es / Fen\u00eatre SQL (on peut aussi le lancer via F2). : Cr\u00e9ation de tables # Depuis QGIS : dans le gestionnaire de base de donn\u00e9es, menu Table / Cr\u00e9er une table : choisir le sch\u00e9ma et le nom de la table, en minuscule, sans accents ni caract\u00e8res complexes Via le bouton Ajouter un champ , on commence par ajouter un champ id de type serial (entier auto-incr\u00e9ment\u00e9), puis d'autres champs en choisissant le nom et le type. Choisir des noms de champ simples ! Choisir dans la liste d\u00e9roulante le champ de cl\u00e9 primaire (ici id) Cocher Cr\u00e9er une colonne g\u00e9om\u00e9trique et choisir le type et le SRID (par exemple 2154 pour le Lambert 93) Cocher Cr\u00e9er un index spatial NB : on a cr\u00e9\u00e9 une table dans cet exemple z_formation.borne_incendie avec les champs id_borne (text), code (text), debit (real) et geom (g\u00e9om\u00e9trie de type Point, code SRID 2154) Cr\u00e9er une table en SQL 1 2 3 4 5 6 7 8 9 10 11 12 13 14 -- cr\u00e9ation d'un sch\u00e9ma CREATE SCHEMA IF NOT EXISTS z_formation ; -- cr\u00e9ation de la table CREATE TABLE z_formation . borne_incendie ( -- un serial est un entier auto-incr\u00e9ment\u00e9 id_borne serial NOT NULL PRIMARY KEY , code text NOT NULL , debit real , geom geometry ( Point , 2154 ) ); -- Cr\u00e9ation de l'index spatial DROP INDEX IF EXISTS borne_incendie_geom_idx ; CREATE INDEX ON z_formation . borne_incendie USING GIST ( geom ); Ajouter des donn\u00e9es dans une table # On peut bien s\u00fbr charger la table dans QGIS, puis utiliser les outils d'\u00e9dition classique pour cr\u00e9er des nouveaux objets. En SQL, il est aussi possible d'ins\u00e9rer des donn\u00e9es ( https://sql.sh/cours/insert-into ). Par exemple pour les bornes \u00e0 incendie: 1 2 3 4 5 6 7 INSERT INTO z_formation . borne_incendie ( code , debit , geom ) VALUES ( 'ABC' , 1 . 5 , ST_SetSRID ( ST_MakePoint ( 490846 . 0 , 6936902 . 7 ), 2154 )), ( 'XYZ' , 4 . 1 , ST_SetSRID ( ST_MakePoint ( 491284 . 9 , 6936551 . 6 ), 2154 )), ( 'FGH' , 2 . 9 , ST_SetSRID ( ST_MakePoint ( 490839 . 8 , 6937794 . 8 ), 2154 )), ( 'IOP' , 3 . 6 , ST_SetSRID ( ST_MakePoint ( 491203 . 3 , 6937488 . 1 ), 2154 )) ; NB : Nous verrons plus loin l'utlisation de fonctions de cr\u00e9ation de g\u00e9om\u00e9trie, comme ST_MakePoint Cr\u00e9ation d\u2019un sch\u00e9ma z_formation dans la base # ajout du sch\u00e9ma via le gestionnaire de bdd, ou via une requ\u00eate: 1 CREATE SCHEMA IF NOT EXISTS z_formation ; modification des droits d\u2019acc\u00e8s \u00e0 ce sch\u00e9ma, si besoin: 1 2 -- On donne ici tous les droits \u00e0 \"utilisateur\" GRANT ALL PRIVILEGES ON SCHEMA z_formation TO \"utilisateur\" ; suppression d'un sch\u00e9ma 1 2 3 4 5 -- Suppression du sch\u00e9ma si il est vide DROP SCHEMA monschema ; -- suppression du sch\u00e9ma et de toutes les tables de ce sch\u00e9ma (via CASCADE) !!! ATTENTION !!! DROP SCHEMA monschema CASCADE ; renommer un sch\u00e9ma 1 ALTER SCHEMA monschema RENAME TO unschema ; V\u00e9rifier et cr\u00e9er les indexes spatiaux # On peut v\u00e9rifier si chaque table contient un index spatial via le gestionnaire de base de donn\u00e9es de QGIS, en cliquant sur la table dans l'arbre, puis en regardant les informations de l'onglet Info . On peut alors cr\u00e9er l'index spatial via le lien bleu Aucun index spatial d\u00e9fini (en cr\u00e9er un) . Sinon, il est possible de le faire en SQL via la requ\u00eate suivante: 1 CREATE INDEX ON nom_du_schema . nom_de_la_table USING GIST ( geom ); Si on souhaite automatiser la cr\u00e9ation des indexes pour toutes les tables qui n'en ont pas, on peut utiliser une fonction, d\u00e9crite dans la partie Fonctions utiles Continuer vers l' Import des donn\u00e9es dans PostgreSQL","title":"Gestion des donn\u00e9es"},{"location":"postgresql_in_qgis/#gestion-des-donnees-postgresql-dans-qgis","text":"","title":"Gestion des donn\u00e9es PostgreSQL dans QGIS"},{"location":"postgresql_in_qgis/#introduction","text":"Lorsqu'on travaille avec des donn\u00e9es PostgreSQL , QGIS n'acc\u00e8de pas \u00e0 la donn\u00e9e en lisant un ou plusieurs fichiers, mais fait des requ\u00eates \u00e0 la base, \u00e0 chaque fois qu'il en a besoin: d\u00e9placement de carte, zoom, ouverture de la table attributaire, s\u00e9lection par expression, etc. QGIS se connecte \u00e0 la base de donn\u00e9es, et r\u00e9cup\u00e8re des donn\u00e9es qui sont stock\u00e9es dans des tables. Il doit donc t\u00e9l\u00e9charger la donn\u00e9e \u00e0 chaque action (pas de cache car la donn\u00e9e peut changer entre temps). une table \u00e9quivaut \u00e0 une couche SIG, d\u00e9finie par un nom, une liste de champs typ\u00e9s, et un ou plusieurs champs de g\u00e9om\u00e9trie. une g\u00e9om\u00e9trie est caract\u00e9ris\u00e9e par un type (polygone, point, ligne, etc.), une dimension (2D ou 3D) et une projection (Ex: EPSG:2154) codifi\u00e9e via un SRID ( Ex: 2154) certaines tables n'ont pas de g\u00e9om\u00e9trie: on les appelle alors non spatiales. QGIS sait les exploiter, ce qui permet de stocker des informations de contexte (nomenclature, \u00e9v\u00e9nements). La base de donn\u00e9es fournit donc un lieu de stockage des donn\u00e9es centralis\u00e9. On peut g\u00e9rer les droits d'acc\u00e8s ou d'\u00e9criture sur les sch\u00e9mas et les tables.","title":"Introduction"},{"location":"postgresql_in_qgis/#creer-une-connexion-qgis-a-la-base-de-donnees","text":"Dans QGIS, il faut cr\u00e9er une nouvelle connexion \u00e0 PostgreSQL, via l'outil \"El\u00e9phant\" : menu Couches / Ajouter une couche / Ajouter une couche PostgreSQL . Configurer les options suivantes: laisser le champ Service vide cocher les cases Enregistrer \u00e0 c\u00f4t\u00e9 de l'utilisateur et du mot de passe, apr\u00e8s avoir Tester la connexion (via le bouton d\u00e9di\u00e9) cocher la case en bas Utiliser la table de m\u00e9tadonn\u00e9es estim\u00e9es Valider Attention Pour plus de s\u00e9curit\u00e9, privil\u00e9gier l'usage d'un service PostgreSQL: https://docs.qgis.org/latest/fr/docs/user_manual/managing_data_source/opening_data.html#pg-service-file Il est aussi int\u00e9ressant pour les performances d'acc\u00e8s aux donn\u00e9es PostgreSQL de modifier une option dans les options de QGIS, onglet Rendu : il faut cocher la case R\u00e9aliser la simplification par le fournisseur de donn\u00e9es lorsque c'est possible . Cela permet de t\u00e9l\u00e9charger des versions all\u00e9g\u00e9es des donn\u00e9es aux petites \u00e9chelles. Documentation NB Pour les couches PostGIS qui auraient d\u00e9j\u00e0 \u00e9t\u00e9 ajout\u00e9es avant d'avoir activ\u00e9 cette option, vous pouvez manuellement changer dans vos projets via l'onglet Rendu de la bo\u00eete de dialogue des propri\u00e9t\u00e9s de chaque couche PostGIS.","title":"Cr\u00e9er une connexion QGIS \u00e0 la base de donn\u00e9es"},{"location":"postgresql_in_qgis/#ouvrir-une-couche-postgresql-dans-qgis","text":"Trois solutions sont possibles: utiliser l'explorateur : seulement pour les tables spatiales, sauf si on a coch\u00e9 Lister les tables sans g\u00e9om\u00e9tries dans les propri\u00e9t\u00e9s de la connexion. Le panneau pr\u00e9sente un arbre qui liste les sch\u00e9mas, puis les tables ou vues exploitables. Une ic\u00f4ne devant chaque table/vue indique si une table est g\u00e9om\u00e9trique ou non ainsi que le type de g\u00e9om\u00e9trie, point, ligne ou polyg\u00f4ne. utiliser le menu Couche / Ajouter une couche . La boite de dialogue propose de se connecter, puis liste les sch\u00e9mas et les tables utiliser le Gestionnaire de base de donn\u00e9es , qui pr\u00e9sente une fen\u00eatre QGIS s\u00e9par\u00e9e d\u00e9di\u00e9e aux manipulations sur les donn\u00e9es.","title":"Ouvrir une couche PostgreSQL dans QGIS"},{"location":"postgresql_in_qgis/#le-gestionnaire-de-base-de-donnees","text":"On travaille via QGIS, avec le gestionnaire de bases de donn\u00e9es : menu Base de donn\u00e9es > Gestionnaire BD (sinon via l'ic\u00f4ne de la barre d\u2019outil base de donn\u00e9es). Dans l'arbre qui se pr\u00e9sente \u00e0 gauche du gestionnaire de bdd, on peut choisir sa connexion , puis double-cliquer, ce qui montre l'ensemble des sch\u00e9mas , et l'ouverture d'un sch\u00e9ma montre la liste des tables et vues. Les menus du gestionnaire permettent de cr\u00e9er ou d'\u00e9diter des objets (sch\u00e9mas, tables). Une fen\u00eatre SQL permet de lancer manuellement des requ\u00eates SQL. Nous allons principalement utiliser cet outil : menu Base de donn\u00e9es / Fen\u00eatre SQL (on peut aussi le lancer via F2). :","title":"Le Gestionnaire de base de donn\u00e9es"},{"location":"postgresql_in_qgis/#creation-de-tables","text":"Depuis QGIS : dans le gestionnaire de base de donn\u00e9es, menu Table / Cr\u00e9er une table : choisir le sch\u00e9ma et le nom de la table, en minuscule, sans accents ni caract\u00e8res complexes Via le bouton Ajouter un champ , on commence par ajouter un champ id de type serial (entier auto-incr\u00e9ment\u00e9), puis d'autres champs en choisissant le nom et le type. Choisir des noms de champ simples ! Choisir dans la liste d\u00e9roulante le champ de cl\u00e9 primaire (ici id) Cocher Cr\u00e9er une colonne g\u00e9om\u00e9trique et choisir le type et le SRID (par exemple 2154 pour le Lambert 93) Cocher Cr\u00e9er un index spatial NB : on a cr\u00e9\u00e9 une table dans cet exemple z_formation.borne_incendie avec les champs id_borne (text), code (text), debit (real) et geom (g\u00e9om\u00e9trie de type Point, code SRID 2154) Cr\u00e9er une table en SQL 1 2 3 4 5 6 7 8 9 10 11 12 13 14 -- cr\u00e9ation d'un sch\u00e9ma CREATE SCHEMA IF NOT EXISTS z_formation ; -- cr\u00e9ation de la table CREATE TABLE z_formation . borne_incendie ( -- un serial est un entier auto-incr\u00e9ment\u00e9 id_borne serial NOT NULL PRIMARY KEY , code text NOT NULL , debit real , geom geometry ( Point , 2154 ) ); -- Cr\u00e9ation de l'index spatial DROP INDEX IF EXISTS borne_incendie_geom_idx ; CREATE INDEX ON z_formation . borne_incendie USING GIST ( geom );","title":"Cr\u00e9ation de tables"},{"location":"postgresql_in_qgis/#ajouter-des-donnees-dans-une-table","text":"On peut bien s\u00fbr charger la table dans QGIS, puis utiliser les outils d'\u00e9dition classique pour cr\u00e9er des nouveaux objets. En SQL, il est aussi possible d'ins\u00e9rer des donn\u00e9es ( https://sql.sh/cours/insert-into ). Par exemple pour les bornes \u00e0 incendie: 1 2 3 4 5 6 7 INSERT INTO z_formation . borne_incendie ( code , debit , geom ) VALUES ( 'ABC' , 1 . 5 , ST_SetSRID ( ST_MakePoint ( 490846 . 0 , 6936902 . 7 ), 2154 )), ( 'XYZ' , 4 . 1 , ST_SetSRID ( ST_MakePoint ( 491284 . 9 , 6936551 . 6 ), 2154 )), ( 'FGH' , 2 . 9 , ST_SetSRID ( ST_MakePoint ( 490839 . 8 , 6937794 . 8 ), 2154 )), ( 'IOP' , 3 . 6 , ST_SetSRID ( ST_MakePoint ( 491203 . 3 , 6937488 . 1 ), 2154 )) ; NB : Nous verrons plus loin l'utlisation de fonctions de cr\u00e9ation de g\u00e9om\u00e9trie, comme ST_MakePoint","title":"Ajouter des donn\u00e9es dans une table"},{"location":"postgresql_in_qgis/#creation-dun-schema-z_formation-dans-la-base","text":"ajout du sch\u00e9ma via le gestionnaire de bdd, ou via une requ\u00eate: 1 CREATE SCHEMA IF NOT EXISTS z_formation ; modification des droits d\u2019acc\u00e8s \u00e0 ce sch\u00e9ma, si besoin: 1 2 -- On donne ici tous les droits \u00e0 \"utilisateur\" GRANT ALL PRIVILEGES ON SCHEMA z_formation TO \"utilisateur\" ; suppression d'un sch\u00e9ma 1 2 3 4 5 -- Suppression du sch\u00e9ma si il est vide DROP SCHEMA monschema ; -- suppression du sch\u00e9ma et de toutes les tables de ce sch\u00e9ma (via CASCADE) !!! ATTENTION !!! DROP SCHEMA monschema CASCADE ; renommer un sch\u00e9ma 1 ALTER SCHEMA monschema RENAME TO unschema ;","title":"Cr\u00e9ation d\u2019un sch\u00e9ma z_formation dans la base"},{"location":"postgresql_in_qgis/#verifier-et-creer-les-indexes-spatiaux","text":"On peut v\u00e9rifier si chaque table contient un index spatial via le gestionnaire de base de donn\u00e9es de QGIS, en cliquant sur la table dans l'arbre, puis en regardant les informations de l'onglet Info . On peut alors cr\u00e9er l'index spatial via le lien bleu Aucun index spatial d\u00e9fini (en cr\u00e9er un) . Sinon, il est possible de le faire en SQL via la requ\u00eate suivante: 1 CREATE INDEX ON nom_du_schema . nom_de_la_table USING GIST ( geom ); Si on souhaite automatiser la cr\u00e9ation des indexes pour toutes les tables qui n'en ont pas, on peut utiliser une fonction, d\u00e9crite dans la partie Fonctions utiles Continuer vers l' Import des donn\u00e9es dans PostgreSQL","title":"V\u00e9rifier et cr\u00e9er les indexes spatiaux"},{"location":"save_queries/","text":"Enregistrer une requ\u00eate # Les vues # Une vue est l'enregistrement d'une requ\u00eate, appel\u00e9e d\u00e9finition de la vue , qui est stock\u00e9 dans la base, et peut \u00eatre utilis\u00e9e comme une table . Cr\u00e9er une vue via CREATE VIEW 1 2 3 4 5 6 7 -- On supprime d'abord la vue si elle existe DROP VIEW IF EXISTS z_formation . v_voies ; -- On cr\u00e9e la vue en r\u00e9cup\u00e9rant les routes de plus de 5 km CREATE VIEW z_formation . v_voies AS SELECT id_route , id AS code , ST_Length ( geom ) AS longueur , geom FROM z_formation . route WHERE ST_Length ( geom ) > 5000 Utiliser cette vue dans une autre requ\u00eate pour filtrer les donn\u00e9es 1 2 3 -- Ou filtrer les donn\u00e9es SELECT * FROM z_formation . v_voies WHERE longueur > 10000 Enregistrer une requ\u00eate comme une table # C'est la m\u00eame chose que pour enregistrer une vue, sauf qu'on cr\u00e9e une table: les donn\u00e9es sont donc stock\u00e9es en base, et n'\u00e9voluent plus en fonction des donn\u00e9es source. Cela permet d'acc\u00e9der rapidement aux donn\u00e9es, car la requ\u00eate sous-jacente n'est plus ex\u00e9cut\u00e9e une fois la table cr\u00e9\u00e9e. Exemple 1 - cr\u00e9er la table des voies rassemblant les routes et les chemins # 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 DROP TABLE IF EXISTS z_formation . t_voies ; CREATE TABLE z_formation . t_voies AS SELECT -- on r\u00e9cup\u00e8re tous les champs source . * , -- on calcule la longueur apr\u00e8s rassemblement des donn\u00e9es ST_Length ( geom ) AS longueur FROM ( ( SELECT id , geom FROM z_formation . chemin LIMIT 100 ) UNION ALL ( SELECT id , geom FROM z_formation . route LIMIT 100 ) ) AS source ORDER BY longueur ; Comme c'est une table, il est int\u00e9ressant d'ajouter un index spatial. 1 CREATE INDEX ON z_formation . t_voies USING GIST ( geom ); On peut aussi ajouter une cl\u00e9 primaire 1 2 ALTER TABLE z_formation . t_voies ADD COLUMN gid serial ; ALTER TABLE z_formation . t_voies ADD PRIMARY KEY ( gid ); Attention Les donn\u00e9es de la table n'\u00e9voluent plus en fonction des donn\u00e9es des tables source. Il faut donc supprimer la table puis la recr\u00e9er si besoin. Pour r\u00e9pondre \u00e0 ce besoin, il existe les vues mat\u00e9rialis\u00e9es . Exemple 2 - cr\u00e9er une table de nomenclature \u00e0 partir des valeurs distinctes d'un champ. # On cr\u00e9e la table si besoin. On ajoutera ensuite les donn\u00e9es via INSERT 1 2 3 4 5 6 7 8 9 -- Suppression de la table DROP TABLE IF EXISTS z_formation . nomenclature ; -- Cr\u00e9ation de la table CREATE TABLE z_formation . nomenclature ( id serial primary key , code text , libelle text , ordre smallint ); On ajoute ensuite les donn\u00e9es. La clause WITH permet de r\u00e9aliser une sous-requ\u00eate, et de l'utiliser ensuite comme une table. La clause INSERT INTO permet d'ajouter les donn\u00e9es. On ne lui passe pas le champ id, car c'est un serial , c'est-\u00e0-dire un entier auto-incr\u00e9ment\u00e9 . 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 -- Ajout des donn\u00e9es \u00e0 partir d'une table via commande INSERT INSERT INTO z_formation . nomenclature ( code , libelle , ordre ) -- Clause WITH pour r\u00e9cup\u00e9rer les valeurs distinctes comme une table virtuelle WITH source AS ( SELECT DISTINCT nature AS libelle FROM z_formation . lieu_dit_habite WHERE nature IS NOT NULL ORDER BY nature ) -- S\u00e9lection des donn\u00e9es dans cette table virtuelle \"source\" SELECT -- on cr\u00e9e un code \u00e0 partir de l'ordre d'arrive. -- row_number() OVER() permet de r\u00e9cup\u00e9rer l'identifiant de la ligne dans l'ordre d'arriv\u00e9e -- (un_champ)::text permet de convertir un champ ou un calcul en texte -- lpad permet de compl\u00e9ter le chiffre avec des z\u00e9ro. 1 devient 01 lpad ( ( row_number () OVER ()):: text , 2 , '0' ) AS code , libelle , row_number () OVER () AS ordre FROM source ; Le r\u00e9sultat est le suivant: code libelle ordre 01 Ch\u00e2teau 1 02 Lieu-dit habit\u00e9 2 03 Moulin 3 04 Quartier 4 05 Refuge 5 06 Ruines 6 Exemple 3 - cr\u00e9er une table avec l'extraction des parcelles sur une commune # On utilise le champ commune pour filtrer. On n'oublie pas de cr\u00e9er l'index spatial, qui sera utilis\u00e9 pour am\u00e9liorer les performances lors des jointures spatiales. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 -- supprimer la table si elle existe d\u00e9j\u00e0 DROP TABLE IF EXISTS z_formation . parcelle_havre ; -- Cr\u00e9er la table via filtre sur le champ commune CREATE TABLE z_formation . parcelle_havre AS SELECT p . * FROM z_formation . parcelle AS p WHERE p . commune = '76351' ; -- Ajouter la cl\u00e9 primaire ALTER TABLE z_formation . parcelle_havre ADD PRIMARY KEY ( id_parcelle ); -- Ajouter l'index spatial CREATE INDEX ON z_formation . parcelle_havre USING GIST ( geom ); Enregistrer une requ\u00eate comme une vue mat\u00e9rialis\u00e9e # 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 -- On supprime d'abord la vue mat\u00e9rialis\u00e9e si elle existe DROP MATERIALIZED VIEW IF EXISTS z_formation . vm_voies ; -- On cr\u00e9e la vue en r\u00e9cup\u00e9rant les routes de plus de 5 km CREATE MATERIALIZED VIEW z_formation . vm_voies AS SELECT id_route , id AS code , ST_Length ( geom ) AS longueur , geom FROM z_formation . route WHERE ST_Length ( geom ) > 6000 -- Ajout des indexes sur le champ id_route et de g\u00e9om\u00e9trie CREATE INDEX ON z_formation . vm_voies ( id_route ); CREATE INDEX ON z_formation . vm_voies USING GIST ( geom ); -- On rafra\u00eechit la vue mat\u00e9rialis\u00e9e quand on en a besoin -- par exemple quand les donn\u00e9es source ont \u00e9t\u00e9 modifi\u00e9es REFRESH MATERIALIZED VIEW z_formation . vm_voies ; Continuer vers R\u00e9aliser des jointures attributaires et spatiales; JOIN","title":"Enregistrer"},{"location":"save_queries/#enregistrer-une-requete","text":"","title":"Enregistrer une requ\u00eate"},{"location":"save_queries/#les-vues","text":"Une vue est l'enregistrement d'une requ\u00eate, appel\u00e9e d\u00e9finition de la vue , qui est stock\u00e9 dans la base, et peut \u00eatre utilis\u00e9e comme une table . Cr\u00e9er une vue via CREATE VIEW 1 2 3 4 5 6 7 -- On supprime d'abord la vue si elle existe DROP VIEW IF EXISTS z_formation . v_voies ; -- On cr\u00e9e la vue en r\u00e9cup\u00e9rant les routes de plus de 5 km CREATE VIEW z_formation . v_voies AS SELECT id_route , id AS code , ST_Length ( geom ) AS longueur , geom FROM z_formation . route WHERE ST_Length ( geom ) > 5000 Utiliser cette vue dans une autre requ\u00eate pour filtrer les donn\u00e9es 1 2 3 -- Ou filtrer les donn\u00e9es SELECT * FROM z_formation . v_voies WHERE longueur > 10000","title":"Les vues"},{"location":"save_queries/#enregistrer-une-requete-comme-une-table","text":"C'est la m\u00eame chose que pour enregistrer une vue, sauf qu'on cr\u00e9e une table: les donn\u00e9es sont donc stock\u00e9es en base, et n'\u00e9voluent plus en fonction des donn\u00e9es source. Cela permet d'acc\u00e9der rapidement aux donn\u00e9es, car la requ\u00eate sous-jacente n'est plus ex\u00e9cut\u00e9e une fois la table cr\u00e9\u00e9e.","title":"Enregistrer une requ\u00eate comme une table"},{"location":"save_queries/#exemple-1-creer-la-table-des-voies-rassemblant-les-routes-et-les-chemins","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 DROP TABLE IF EXISTS z_formation . t_voies ; CREATE TABLE z_formation . t_voies AS SELECT -- on r\u00e9cup\u00e8re tous les champs source . * , -- on calcule la longueur apr\u00e8s rassemblement des donn\u00e9es ST_Length ( geom ) AS longueur FROM ( ( SELECT id , geom FROM z_formation . chemin LIMIT 100 ) UNION ALL ( SELECT id , geom FROM z_formation . route LIMIT 100 ) ) AS source ORDER BY longueur ; Comme c'est une table, il est int\u00e9ressant d'ajouter un index spatial. 1 CREATE INDEX ON z_formation . t_voies USING GIST ( geom ); On peut aussi ajouter une cl\u00e9 primaire 1 2 ALTER TABLE z_formation . t_voies ADD COLUMN gid serial ; ALTER TABLE z_formation . t_voies ADD PRIMARY KEY ( gid ); Attention Les donn\u00e9es de la table n'\u00e9voluent plus en fonction des donn\u00e9es des tables source. Il faut donc supprimer la table puis la recr\u00e9er si besoin. Pour r\u00e9pondre \u00e0 ce besoin, il existe les vues mat\u00e9rialis\u00e9es .","title":"Exemple 1 - cr\u00e9er la table des voies rassemblant les routes et les chemins"},{"location":"save_queries/#exemple-2-creer-une-table-de-nomenclature-a-partir-des-valeurs-distinctes-dun-champ","text":"On cr\u00e9e la table si besoin. On ajoutera ensuite les donn\u00e9es via INSERT 1 2 3 4 5 6 7 8 9 -- Suppression de la table DROP TABLE IF EXISTS z_formation . nomenclature ; -- Cr\u00e9ation de la table CREATE TABLE z_formation . nomenclature ( id serial primary key , code text , libelle text , ordre smallint ); On ajoute ensuite les donn\u00e9es. La clause WITH permet de r\u00e9aliser une sous-requ\u00eate, et de l'utiliser ensuite comme une table. La clause INSERT INTO permet d'ajouter les donn\u00e9es. On ne lui passe pas le champ id, car c'est un serial , c'est-\u00e0-dire un entier auto-incr\u00e9ment\u00e9 . 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 -- Ajout des donn\u00e9es \u00e0 partir d'une table via commande INSERT INSERT INTO z_formation . nomenclature ( code , libelle , ordre ) -- Clause WITH pour r\u00e9cup\u00e9rer les valeurs distinctes comme une table virtuelle WITH source AS ( SELECT DISTINCT nature AS libelle FROM z_formation . lieu_dit_habite WHERE nature IS NOT NULL ORDER BY nature ) -- S\u00e9lection des donn\u00e9es dans cette table virtuelle \"source\" SELECT -- on cr\u00e9e un code \u00e0 partir de l'ordre d'arrive. -- row_number() OVER() permet de r\u00e9cup\u00e9rer l'identifiant de la ligne dans l'ordre d'arriv\u00e9e -- (un_champ)::text permet de convertir un champ ou un calcul en texte -- lpad permet de compl\u00e9ter le chiffre avec des z\u00e9ro. 1 devient 01 lpad ( ( row_number () OVER ()):: text , 2 , '0' ) AS code , libelle , row_number () OVER () AS ordre FROM source ; Le r\u00e9sultat est le suivant: code libelle ordre 01 Ch\u00e2teau 1 02 Lieu-dit habit\u00e9 2 03 Moulin 3 04 Quartier 4 05 Refuge 5 06 Ruines 6","title":"Exemple 2 - cr\u00e9er une table de nomenclature \u00e0 partir des valeurs distinctes d'un champ."},{"location":"save_queries/#exemple-3-creer-une-table-avec-lextraction-des-parcelles-sur-une-commune","text":"On utilise le champ commune pour filtrer. On n'oublie pas de cr\u00e9er l'index spatial, qui sera utilis\u00e9 pour am\u00e9liorer les performances lors des jointures spatiales. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 -- supprimer la table si elle existe d\u00e9j\u00e0 DROP TABLE IF EXISTS z_formation . parcelle_havre ; -- Cr\u00e9er la table via filtre sur le champ commune CREATE TABLE z_formation . parcelle_havre AS SELECT p . * FROM z_formation . parcelle AS p WHERE p . commune = '76351' ; -- Ajouter la cl\u00e9 primaire ALTER TABLE z_formation . parcelle_havre ADD PRIMARY KEY ( id_parcelle ); -- Ajouter l'index spatial CREATE INDEX ON z_formation . parcelle_havre USING GIST ( geom );","title":"Exemple 3 - cr\u00e9er une table avec l'extraction des parcelles sur une commune"},{"location":"save_queries/#enregistrer-une-requete-comme-une-vue-materialisee","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 -- On supprime d'abord la vue mat\u00e9rialis\u00e9e si elle existe DROP MATERIALIZED VIEW IF EXISTS z_formation . vm_voies ; -- On cr\u00e9e la vue en r\u00e9cup\u00e9rant les routes de plus de 5 km CREATE MATERIALIZED VIEW z_formation . vm_voies AS SELECT id_route , id AS code , ST_Length ( geom ) AS longueur , geom FROM z_formation . route WHERE ST_Length ( geom ) > 6000 -- Ajout des indexes sur le champ id_route et de g\u00e9om\u00e9trie CREATE INDEX ON z_formation . vm_voies ( id_route ); CREATE INDEX ON z_formation . vm_voies USING GIST ( geom ); -- On rafra\u00eechit la vue mat\u00e9rialis\u00e9e quand on en a besoin -- par exemple quand les donn\u00e9es source ont \u00e9t\u00e9 modifi\u00e9es REFRESH MATERIALIZED VIEW z_formation . vm_voies ; Continuer vers R\u00e9aliser des jointures attributaires et spatiales; JOIN","title":"Enregistrer une requ\u00eate comme une vue mat\u00e9rialis\u00e9e"},{"location":"sql_select/","text":"S\u00e9lectionner # Nous allons pr\u00e9senter des requ\u00eates SQL de plus en plus complexes pour acc\u00e9der aux donn\u00e9es, et exploiter les capacit\u00e9s de PostgreSQL/PostGIS. Une requ\u00eate est construite avec des instructions standardis\u00e9es, appel\u00e9es clauses 1 2 3 4 5 6 7 8 9 -- Ordre des clauses SQL SELECT une_colonne , une_autre_colonne FROM nom_du_schema . nom_de_la_table ( LEFT ) JOIN autre_schema . autre_table ON critere_de_jointure WHERE condition GROUP BY champs_de_regroupement ORDER BY champs_d_ordre LIMIT 10 R\u00e9cup\u00e9rer tous les objets d'une table, et les valeurs pour toutes les colonnes 1 2 3 4 -- S\u00e9lectionner l'ensemble des donn\u00e9es d'une couche: l'\u00e9toile veut dire \"tous les champs de la table\" SELECT * FROM z_formation . borne_incendie ; Les 10 premiers objets 1 2 3 4 5 -- S\u00e9lectionner les 10 premi\u00e8res communes par ordre alphab\u00e9tique SELECT * FROM z_formation . commune ORDER BY nom LIMIT 10 Les 10 premiers objets par ordre alphab\u00e9tique 1 2 3 4 5 -- S\u00e9lectionner les 10 premi\u00e8res communes par ordre alphab\u00e9tique descendant SELECT * FROM z_formation . commune ORDER BY nom DESC LIMIT 10 Les 10 premiers objets avec un ordre sur plusieurs champs 1 2 3 4 5 -- On peut utiliser plusieurs champs pour l'ordre SELECT * FROM z_formation . commune ORDER BY depart , nom LIMIT 10 S\u00e9lectionner seulement certains champs 1 2 3 4 -- S\u00e9lectionner seulement certains champs, et avec un ordre SELECT id_commune , code_insee , nom FROM z_formation . commune ORDER BY nom Donner un alias (un autre nom) aux champs 1 2 3 4 5 6 -- Donner des alias aux noms des colonnes SELECT id_commune AS identifiant , code_insee AS \"code_commune\" , nom FROM z_formation . commune ORDER BY nom On peut donc facilement, \u00e0 partir de la clause SELECT, choisir quels champs on souhaite r\u00e9cup\u00e9rer, dans l'ordre voulu, et renommer le champ en sortie. Visualiser une requ\u00eate dans QGIS # Si on veut charger le r\u00e9sultat de la requ\u00eate dans QGIS, il suffit de cocher la case Charger en tant que nouvelle couche puis de choisir le champ d' identifiant unique , et si et seulement si c'est une couche spatiale, choisir le champ de g\u00e9om\u00e9trie . Attention, si la table est non spatiale, il faut bien penser \u00e0 d\u00e9cocher Colonne de g\u00e9om\u00e9trie ! Par exemple, pour afficher les communes avec leur information sommaire: 1 2 3 4 5 6 -- Ajouter la g\u00e9om\u00e9trie pour visualiser les donn\u00e9es dans QGIS SELECT id_commune AS identifiant , code_insee AS \"code_commune\" , nom , geom FROM z_formation . commune ORDER BY nom On choisira ici le champ identifiant comme identifiant unique, et le champ geom comme g\u00e9om\u00e9trie Continuer vers R\u00e9aliser des calculs et cr\u00e9er des g\u00e9om\u00e9tries: FONCTIONS","title":"S\u00e9lection"},{"location":"sql_select/#selectionner","text":"Nous allons pr\u00e9senter des requ\u00eates SQL de plus en plus complexes pour acc\u00e9der aux donn\u00e9es, et exploiter les capacit\u00e9s de PostgreSQL/PostGIS. Une requ\u00eate est construite avec des instructions standardis\u00e9es, appel\u00e9es clauses 1 2 3 4 5 6 7 8 9 -- Ordre des clauses SQL SELECT une_colonne , une_autre_colonne FROM nom_du_schema . nom_de_la_table ( LEFT ) JOIN autre_schema . autre_table ON critere_de_jointure WHERE condition GROUP BY champs_de_regroupement ORDER BY champs_d_ordre LIMIT 10 R\u00e9cup\u00e9rer tous les objets d'une table, et les valeurs pour toutes les colonnes 1 2 3 4 -- S\u00e9lectionner l'ensemble des donn\u00e9es d'une couche: l'\u00e9toile veut dire \"tous les champs de la table\" SELECT * FROM z_formation . borne_incendie ; Les 10 premiers objets 1 2 3 4 5 -- S\u00e9lectionner les 10 premi\u00e8res communes par ordre alphab\u00e9tique SELECT * FROM z_formation . commune ORDER BY nom LIMIT 10 Les 10 premiers objets par ordre alphab\u00e9tique 1 2 3 4 5 -- S\u00e9lectionner les 10 premi\u00e8res communes par ordre alphab\u00e9tique descendant SELECT * FROM z_formation . commune ORDER BY nom DESC LIMIT 10 Les 10 premiers objets avec un ordre sur plusieurs champs 1 2 3 4 5 -- On peut utiliser plusieurs champs pour l'ordre SELECT * FROM z_formation . commune ORDER BY depart , nom LIMIT 10 S\u00e9lectionner seulement certains champs 1 2 3 4 -- S\u00e9lectionner seulement certains champs, et avec un ordre SELECT id_commune , code_insee , nom FROM z_formation . commune ORDER BY nom Donner un alias (un autre nom) aux champs 1 2 3 4 5 6 -- Donner des alias aux noms des colonnes SELECT id_commune AS identifiant , code_insee AS \"code_commune\" , nom FROM z_formation . commune ORDER BY nom On peut donc facilement, \u00e0 partir de la clause SELECT, choisir quels champs on souhaite r\u00e9cup\u00e9rer, dans l'ordre voulu, et renommer le champ en sortie.","title":"S\u00e9lectionner"},{"location":"sql_select/#visualiser-une-requete-dans-qgis","text":"Si on veut charger le r\u00e9sultat de la requ\u00eate dans QGIS, il suffit de cocher la case Charger en tant que nouvelle couche puis de choisir le champ d' identifiant unique , et si et seulement si c'est une couche spatiale, choisir le champ de g\u00e9om\u00e9trie . Attention, si la table est non spatiale, il faut bien penser \u00e0 d\u00e9cocher Colonne de g\u00e9om\u00e9trie ! Par exemple, pour afficher les communes avec leur information sommaire: 1 2 3 4 5 6 -- Ajouter la g\u00e9om\u00e9trie pour visualiser les donn\u00e9es dans QGIS SELECT id_commune AS identifiant , code_insee AS \"code_commune\" , nom , geom FROM z_formation . commune ORDER BY nom On choisira ici le champ identifiant comme identifiant unique, et le champ geom comme g\u00e9om\u00e9trie Continuer vers R\u00e9aliser des calculs et cr\u00e9er des g\u00e9om\u00e9tries: FONCTIONS","title":"Visualiser une requ\u00eate dans QGIS"},{"location":"triggers/","text":"Les triggers # Les triggers , aussi appel\u00e9s en fran\u00e7ais d\u00e9clencheurs , permettent de lancer des actions avant ou apr\u00e8s ajout, modification ou suppression de donn\u00e9es sur des tables (ou des vues). Les triggers peuvent par exemple \u00eatre utilis\u00e9s pour lancer le calcul de certains champs de mani\u00e8re automatique: date de derni\u00e8re modification, utilisateur \u00e0 l'origine d'un ajout pour contr\u00f4ler certaines donn\u00e9es avant enregistrement pour lancer des requ\u00eates apr\u00e8s certaines actions (historiques de modifications) Calcul automatique de certains champs # On cr\u00e9e une table borne_incendie pour pouvoir tester cette fonctionnalit\u00e9: 1 2 3 4 5 6 7 CREATE TABLE z_formation . borne_incendie ( id_borne serial primary key , code text NOT NULL , debit integer , geom geometry ( point , 2154 ) ); CREATE INDEX ON z_formation . borne_incendie USING GIST ( geom ); On y ajoute des champs \u00e0 renseigner de mani\u00e8re automatique 1 2 3 4 5 6 7 8 9 -- TRIGGERS -- Modification de certains champs apr\u00e8s ajout ou modification -- Cr\u00e9er les champs dans la table ALTER TABLE z_formation . borne_incendie ADD COLUMN modif_date date ; ALTER TABLE z_formation . borne_incendie ADD COLUMN modif_user text ; ALTER TABLE z_formation . borne_incendie ADD COLUMN longitude real ; ALTER TABLE z_formation . borne_incendie ADD COLUMN latitude real ; ALTER TABLE z_formation . borne_incendie ADD COLUMN donnee_validee boolean ; ALTER TABLE z_formation . borne_incendie ADD COLUMN last_action text ; On cr\u00e9e la fonction trigger qui ajoutera les m\u00e9tadonn\u00e9es dans la table 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 -- Cr\u00e9er la fonction qui sera lanc\u00e9e sur modif ou ajout de donn\u00e9es CREATE OR REPLACE FUNCTION z_formation . ajout_metadonnees_modification () RETURNS TRIGGER AS $ limite$ DECLARE newjsonb jsonb ; BEGIN -- on transforme l'enregistrement NEW (la ligne modifie ou ajou\u00e9e) en JSON -- pour conna\u00eetre la liste des champs newjsonb = to_jsonb ( NEW ); -- on peut ainsi tester si chaque champ existe dans la table -- avant de modifier sa valeur -- Par exemple, on teste si le champ modif_date est bien dans l'enregistrement courant IF newjsonb ? 'modif_date' THEN NEW . modif_date = now (); RAISE NOTICE 'Date modifi\u00e9e %' , NEW . modif_date ; END IF ; IF newjsonb ? 'modif_user' THEN NEW . modif_user = CURRENT_USER ; END IF ; -- longitude et latitude IF newjsonb ? 'longitude' AND newjsonb ? 'latitude' THEN -- Soit on fait un UPDATE et les g\u00e9om\u00e9tries sont diff\u00e9rentes -- Soit on fait un INSERT -- Sinon pas besoin de calculer les coordonn\u00e9es IF ( TG_OP = 'UPDATE' AND NOT ST_Equals ( OLD . geom , NEW . geom )) OR ( TG_OP = 'INSERT' ) THEN NEW . longitude = ST_X ( ST_Centroid ( NEW . geom )); NEW . latitude = ST_Y ( ST_Centroid ( NEW . geom )); END IF ; END IF ; -- Si je trouve un champ donnee_validee, je le mets \u00e0 False pour revue par l'administrateur -- Je peux faire une symbologie dans QGIS qui montre les donn\u00e9es modifi\u00e9es depuis derni\u00e8re validation IF newjsonb ? 'donnee_validee' THEN NEW . donnee_validee = False ; END IF ; -- Si je trouve un champ last_action, je peux y mettre UPDATE ou INSERT -- Pour savoir quelle est la derni\u00e8re op\u00e9ration utilis\u00e9e IF newjsonb ? 'last_action' THEN NEW . last_action = TG_OP ; END IF ; RETURN NEW ; END ; $ limite$ LANGUAGE plpgsql ; On cr\u00e9e enfin le d\u00e9clencheur pour la ou les tables souhait\u00e9es, ce qui active le lancement de la fonction trigger pr\u00e9c\u00e9dente sur certaines actions: 1 2 3 4 -- Dire \u00e0 PostgreSQL d'\u00e9couter les modifications et ajouts sur la table CREATE TRIGGER trg_ajout_metadonnees_modification BEFORE INSERT OR UPDATE ON z_formation . borne_incendie FOR EACH ROW EXECUTE PROCEDURE z_formation . ajout_metadonnees_modification (); Contr\u00f4les de conformit\u00e9 # Il est aussi possible d'utiliser les triggers pour lancer des contr\u00f4les sur les valeurs de certains champs. Par exemple, on peut ajouter un contr\u00f4le sur la g\u00e9om\u00e9trie lors de l'ajout ou de la modification de donn\u00e9es: on v\u00e9rifie si la g\u00e9om\u00e9trie est bien en intersection avec les objets de la table des communes 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 -- Contr\u00f4le de la g\u00e9om\u00e9trie -- qui doit \u00eatre dans la zone d'int\u00e9r\u00eat -- On cr\u00e9e une fonction g\u00e9n\u00e9rique qui pourra s'appliquer pour toutes les couches CREATE OR REPLACE FUNCTION z_formation . validation_geometrie_dans_zone_interet () RETURNS TRIGGER AS $ limite$ BEGIN -- On v\u00e9rifie l'intersection avec les communes, on renvoit une erreur si souci IF NOT ST_Intersects ( NEW . geom , st_collectionextract (( SELECT ST_Collect ( geom ) FROM z_formation . commune ), 3 ):: geometry ( multipolygon , 2154 ) ) THEN -- On renvoit une erreur RAISE EXCEPTION 'La g\u00e9om\u00e9trie doit se trouver dans les communes' ; END IF ; RETURN NEW ; END ; $ limite$ LANGUAGE plpgsql ; -- On l'applique sur la couches de test DROP TRIGGER IF EXISTS trg_validation_geometrie_dans_zone_interet ON z_formation . borne_incendie ; CREATE TRIGGER trg_validation_geometrie_dans_zone_interet BEFORE INSERT OR UPDATE ON z_formation . borne_incendie FOR EACH ROW EXECUTE PROCEDURE z_formation . validation_geometrie_dans_zone_interet (); Si on essaye de cr\u00e9er un point dans la table z_formation.borne_incendie en dehors des communes, la base renverra une erreur. \u00c9crire les actions produites sur une table # On cr\u00e9e d'abord une table qui permettra de stocker les actions 1 2 3 4 5 6 7 CREATE TABLE IF NOT EXISTS z_formation . log ( id serial primary key , log_date timestamp , log_user text , log_action text , log_data jsonb ); On peut maintenant cr\u00e9er un trigger qui stocke dans cette table les actions effectu\u00e9es. Dans cet exemple, toutes les donn\u00e9es sont stock\u00e9es, mais on pourrait bien s\u00fbr choisir de simplifier cela. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 CREATE OR REPLACE FUNCTION z_formation . log_actions () RETURNS TRIGGER AS $ limite$ DECLARE row_data jsonb ; BEGIN -- We keep data IF TG_OP = 'INSERT' THEN -- for insert, we take the new data row_data = to_jsonb ( NEW ); ELSE -- for UPDATE and DELETE, we keep data before changes row_data = to_jsonb ( OLD ) END IF ; -- We insert a new log item INSERT INTO z_formation . log ( log_date , log_user , log_action , log_data ) VALUES ( now (), CURRENT_USER , TG_OP , row_data ); IF TG_OP != 'DELETE' THEN RETURN NEW ; ELSE RETURN OLD ; END IF ; END ; $ limite$ LANGUAGE plpgsql ; -- On l'applique sur la couches de test -- On \u00e9coute apr\u00e8s l'action, d'o\u00f9 l'utilisation de `AFTER` -- On \u00e9coute pour INSERT, UPDATE ou DELETE DROP TRIGGER IF EXISTS trg_log_actions ON z_formation . borne_incendie ; CREATE TRIGGER trg_log_actions AFTER INSERT OR UPDATE OR DELETE ON z_formation . borne_incendie FOR EACH ROW EXECUTE PROCEDURE z_formation . log_actions (); NB: Attention, ce type de tables de log peut vite devenir tr\u00e8s grosse ! pour un log d'audit plus \u00e9volu\u00e9 r\u00e9alis\u00e9 \u00e0 partir de triggers, vous pouvez consulter le d\u00e9p\u00f4t audit_trigger Continuer vers Correction des g\u00e9om\u00e9tries invalides","title":"Triggers"},{"location":"triggers/#les-triggers","text":"Les triggers , aussi appel\u00e9s en fran\u00e7ais d\u00e9clencheurs , permettent de lancer des actions avant ou apr\u00e8s ajout, modification ou suppression de donn\u00e9es sur des tables (ou des vues). Les triggers peuvent par exemple \u00eatre utilis\u00e9s pour lancer le calcul de certains champs de mani\u00e8re automatique: date de derni\u00e8re modification, utilisateur \u00e0 l'origine d'un ajout pour contr\u00f4ler certaines donn\u00e9es avant enregistrement pour lancer des requ\u00eates apr\u00e8s certaines actions (historiques de modifications)","title":"Les triggers"},{"location":"triggers/#calcul-automatique-de-certains-champs","text":"On cr\u00e9e une table borne_incendie pour pouvoir tester cette fonctionnalit\u00e9: 1 2 3 4 5 6 7 CREATE TABLE z_formation . borne_incendie ( id_borne serial primary key , code text NOT NULL , debit integer , geom geometry ( point , 2154 ) ); CREATE INDEX ON z_formation . borne_incendie USING GIST ( geom ); On y ajoute des champs \u00e0 renseigner de mani\u00e8re automatique 1 2 3 4 5 6 7 8 9 -- TRIGGERS -- Modification de certains champs apr\u00e8s ajout ou modification -- Cr\u00e9er les champs dans la table ALTER TABLE z_formation . borne_incendie ADD COLUMN modif_date date ; ALTER TABLE z_formation . borne_incendie ADD COLUMN modif_user text ; ALTER TABLE z_formation . borne_incendie ADD COLUMN longitude real ; ALTER TABLE z_formation . borne_incendie ADD COLUMN latitude real ; ALTER TABLE z_formation . borne_incendie ADD COLUMN donnee_validee boolean ; ALTER TABLE z_formation . borne_incendie ADD COLUMN last_action text ; On cr\u00e9e la fonction trigger qui ajoutera les m\u00e9tadonn\u00e9es dans la table 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 -- Cr\u00e9er la fonction qui sera lanc\u00e9e sur modif ou ajout de donn\u00e9es CREATE OR REPLACE FUNCTION z_formation . ajout_metadonnees_modification () RETURNS TRIGGER AS $ limite$ DECLARE newjsonb jsonb ; BEGIN -- on transforme l'enregistrement NEW (la ligne modifie ou ajou\u00e9e) en JSON -- pour conna\u00eetre la liste des champs newjsonb = to_jsonb ( NEW ); -- on peut ainsi tester si chaque champ existe dans la table -- avant de modifier sa valeur -- Par exemple, on teste si le champ modif_date est bien dans l'enregistrement courant IF newjsonb ? 'modif_date' THEN NEW . modif_date = now (); RAISE NOTICE 'Date modifi\u00e9e %' , NEW . modif_date ; END IF ; IF newjsonb ? 'modif_user' THEN NEW . modif_user = CURRENT_USER ; END IF ; -- longitude et latitude IF newjsonb ? 'longitude' AND newjsonb ? 'latitude' THEN -- Soit on fait un UPDATE et les g\u00e9om\u00e9tries sont diff\u00e9rentes -- Soit on fait un INSERT -- Sinon pas besoin de calculer les coordonn\u00e9es IF ( TG_OP = 'UPDATE' AND NOT ST_Equals ( OLD . geom , NEW . geom )) OR ( TG_OP = 'INSERT' ) THEN NEW . longitude = ST_X ( ST_Centroid ( NEW . geom )); NEW . latitude = ST_Y ( ST_Centroid ( NEW . geom )); END IF ; END IF ; -- Si je trouve un champ donnee_validee, je le mets \u00e0 False pour revue par l'administrateur -- Je peux faire une symbologie dans QGIS qui montre les donn\u00e9es modifi\u00e9es depuis derni\u00e8re validation IF newjsonb ? 'donnee_validee' THEN NEW . donnee_validee = False ; END IF ; -- Si je trouve un champ last_action, je peux y mettre UPDATE ou INSERT -- Pour savoir quelle est la derni\u00e8re op\u00e9ration utilis\u00e9e IF newjsonb ? 'last_action' THEN NEW . last_action = TG_OP ; END IF ; RETURN NEW ; END ; $ limite$ LANGUAGE plpgsql ; On cr\u00e9e enfin le d\u00e9clencheur pour la ou les tables souhait\u00e9es, ce qui active le lancement de la fonction trigger pr\u00e9c\u00e9dente sur certaines actions: 1 2 3 4 -- Dire \u00e0 PostgreSQL d'\u00e9couter les modifications et ajouts sur la table CREATE TRIGGER trg_ajout_metadonnees_modification BEFORE INSERT OR UPDATE ON z_formation . borne_incendie FOR EACH ROW EXECUTE PROCEDURE z_formation . ajout_metadonnees_modification ();","title":"Calcul automatique de certains champs"},{"location":"triggers/#controles-de-conformite","text":"Il est aussi possible d'utiliser les triggers pour lancer des contr\u00f4les sur les valeurs de certains champs. Par exemple, on peut ajouter un contr\u00f4le sur la g\u00e9om\u00e9trie lors de l'ajout ou de la modification de donn\u00e9es: on v\u00e9rifie si la g\u00e9om\u00e9trie est bien en intersection avec les objets de la table des communes 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 -- Contr\u00f4le de la g\u00e9om\u00e9trie -- qui doit \u00eatre dans la zone d'int\u00e9r\u00eat -- On cr\u00e9e une fonction g\u00e9n\u00e9rique qui pourra s'appliquer pour toutes les couches CREATE OR REPLACE FUNCTION z_formation . validation_geometrie_dans_zone_interet () RETURNS TRIGGER AS $ limite$ BEGIN -- On v\u00e9rifie l'intersection avec les communes, on renvoit une erreur si souci IF NOT ST_Intersects ( NEW . geom , st_collectionextract (( SELECT ST_Collect ( geom ) FROM z_formation . commune ), 3 ):: geometry ( multipolygon , 2154 ) ) THEN -- On renvoit une erreur RAISE EXCEPTION 'La g\u00e9om\u00e9trie doit se trouver dans les communes' ; END IF ; RETURN NEW ; END ; $ limite$ LANGUAGE plpgsql ; -- On l'applique sur la couches de test DROP TRIGGER IF EXISTS trg_validation_geometrie_dans_zone_interet ON z_formation . borne_incendie ; CREATE TRIGGER trg_validation_geometrie_dans_zone_interet BEFORE INSERT OR UPDATE ON z_formation . borne_incendie FOR EACH ROW EXECUTE PROCEDURE z_formation . validation_geometrie_dans_zone_interet (); Si on essaye de cr\u00e9er un point dans la table z_formation.borne_incendie en dehors des communes, la base renverra une erreur.","title":"Contr\u00f4les de conformit\u00e9"},{"location":"triggers/#ecrire-les-actions-produites-sur-une-table","text":"On cr\u00e9e d'abord une table qui permettra de stocker les actions 1 2 3 4 5 6 7 CREATE TABLE IF NOT EXISTS z_formation . log ( id serial primary key , log_date timestamp , log_user text , log_action text , log_data jsonb ); On peut maintenant cr\u00e9er un trigger qui stocke dans cette table les actions effectu\u00e9es. Dans cet exemple, toutes les donn\u00e9es sont stock\u00e9es, mais on pourrait bien s\u00fbr choisir de simplifier cela. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 CREATE OR REPLACE FUNCTION z_formation . log_actions () RETURNS TRIGGER AS $ limite$ DECLARE row_data jsonb ; BEGIN -- We keep data IF TG_OP = 'INSERT' THEN -- for insert, we take the new data row_data = to_jsonb ( NEW ); ELSE -- for UPDATE and DELETE, we keep data before changes row_data = to_jsonb ( OLD ) END IF ; -- We insert a new log item INSERT INTO z_formation . log ( log_date , log_user , log_action , log_data ) VALUES ( now (), CURRENT_USER , TG_OP , row_data ); IF TG_OP != 'DELETE' THEN RETURN NEW ; ELSE RETURN OLD ; END IF ; END ; $ limite$ LANGUAGE plpgsql ; -- On l'applique sur la couches de test -- On \u00e9coute apr\u00e8s l'action, d'o\u00f9 l'utilisation de `AFTER` -- On \u00e9coute pour INSERT, UPDATE ou DELETE DROP TRIGGER IF EXISTS trg_log_actions ON z_formation . borne_incendie ; CREATE TRIGGER trg_log_actions AFTER INSERT OR UPDATE OR DELETE ON z_formation . borne_incendie FOR EACH ROW EXECUTE PROCEDURE z_formation . log_actions (); NB: Attention, ce type de tables de log peut vite devenir tr\u00e8s grosse ! pour un log d'audit plus \u00e9volu\u00e9 r\u00e9alis\u00e9 \u00e0 partir de triggers, vous pouvez consulter le d\u00e9p\u00f4t audit_trigger Continuer vers Correction des g\u00e9om\u00e9tries invalides","title":"\u00c9crire les actions produites sur une table"},{"location":"tutoriel/","text":"Tutoriel # Afin de vous entrainer il existe diff\u00e9rentes tutoriels en ligne vous permettant de vous exercer. https://sql.sh/exercices-sql https://sqlzoo.net/wiki/SQL_Tutorial https://fxjollois.github.io/cours-sql/ http://webtic.free.fr/sql/exint/q1.htm https://www.hackerrank.com/domains/sql","title":"Tutoriels en ligne"},{"location":"tutoriel/#tutoriel","text":"Afin de vous entrainer il existe diff\u00e9rentes tutoriels en ligne vous permettant de vous exercer. https://sql.sh/exercices-sql https://sqlzoo.net/wiki/SQL_Tutorial https://fxjollois.github.io/cours-sql/ http://webtic.free.fr/sql/exint/q1.htm https://www.hackerrank.com/domains/sql","title":"Tutoriel"},{"location":"union/","text":"Rassembler des donn\u00e9es de plusieurs tables # La clause UNION peut \u00eatre utilis\u00e9e pour regrouper les donn\u00e9es de sources diff\u00e9rentes dans une m\u00eame table. Le UNION ALL fait la m\u00eame choses, mais sans r\u00e9aliser de d\u00e9doublonnement, ce qui est plus rapide. Rassembler les routes et les chemins ensemble, en ajoutant un champ \"nature\" pour les diff\u00e9rencier 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 -- Rassembler des donn\u00e9es de tables diff\u00e9rentes -- On utilise une UNION ALL ( SELECT 'chemin' AS nature , geom , ROUND ( ST_LENGTH ( geom )):: integer AS longueur FROM z_formation . chemin LIMIT 100 ) -- UNION ALL est plac\u00e9 entre 2 SELECT UNION ALL ( SELECT 'route' AS nature , geom , ROUND ( ST_LENGTH ( geom )):: integer AS longueur FROM z_formation . route LIMIT 100 ) -- Le ORDER BY doit \u00eatre r\u00e9alis\u00e9 \u00e0 la fin, et non sur chaque SELECT ORDER BY longueur Si on doit r\u00e9aliser le m\u00eame calcul sur chaque sous-ensemble (chaque SELECT), on peut le faire en 2 \u00e9tapes via une sous-requ\u00eate (ou une clause WITH) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 SELECT -- on r\u00e9cup\u00e8re tous les champs source . * , -- on calcule la longueur apr\u00e8s rassemblement des donn\u00e9es st_length ( geom ) AS longueur FROM ( ( SELECT id , geom FROM z_formation . chemin LIMIT 100 ) UNION ALL ( SELECT id , geom FROM z_formation . route LIMIT 100 ) ) AS source ORDER BY longueur DESC ; Continuer vers Enregistrer les requ\u00eates: VIEW","title":"Rassembler"},{"location":"union/#rassembler-des-donnees-de-plusieurs-tables","text":"La clause UNION peut \u00eatre utilis\u00e9e pour regrouper les donn\u00e9es de sources diff\u00e9rentes dans une m\u00eame table. Le UNION ALL fait la m\u00eame choses, mais sans r\u00e9aliser de d\u00e9doublonnement, ce qui est plus rapide. Rassembler les routes et les chemins ensemble, en ajoutant un champ \"nature\" pour les diff\u00e9rencier 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 -- Rassembler des donn\u00e9es de tables diff\u00e9rentes -- On utilise une UNION ALL ( SELECT 'chemin' AS nature , geom , ROUND ( ST_LENGTH ( geom )):: integer AS longueur FROM z_formation . chemin LIMIT 100 ) -- UNION ALL est plac\u00e9 entre 2 SELECT UNION ALL ( SELECT 'route' AS nature , geom , ROUND ( ST_LENGTH ( geom )):: integer AS longueur FROM z_formation . route LIMIT 100 ) -- Le ORDER BY doit \u00eatre r\u00e9alis\u00e9 \u00e0 la fin, et non sur chaque SELECT ORDER BY longueur Si on doit r\u00e9aliser le m\u00eame calcul sur chaque sous-ensemble (chaque SELECT), on peut le faire en 2 \u00e9tapes via une sous-requ\u00eate (ou une clause WITH) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 SELECT -- on r\u00e9cup\u00e8re tous les champs source . * , -- on calcule la longueur apr\u00e8s rassemblement des donn\u00e9es st_length ( geom ) AS longueur FROM ( ( SELECT id , geom FROM z_formation . chemin LIMIT 100 ) UNION ALL ( SELECT id , geom FROM z_formation . route LIMIT 100 ) ) AS source ORDER BY longueur DESC ; Continuer vers Enregistrer les requ\u00eates: VIEW","title":"Rassembler des donn\u00e9es de plusieurs tables"},{"location":"utils/","text":"Fonctions utiles # Nous regroupons ici quelques fonctions r\u00e9alis\u00e9es au cours de formations ou d'accompagnements d'utilisateurs de PostgreSQL. Ajout de l'auto-incr\u00e9mentation sur un champ entier # Lorsqu'on importe une couche dans une table via les outils de QGIS, le champ d'identifiant choisi n'a pas le support de l'auto-incr\u00e9mentation, ce qui peut poser des probl\u00e8mes de l'ajout de nouvelles donn\u00e9es. Par exemple, pour une s\u00e9quence monschema.ma_sequence , si la requ\u00eate suivante \u00e9choue, c'est que la s\u00e9quence n'est en effet pas correctement configur\u00e9e : 1 SELECT currval ( '\"monschema\".\"test_id_seq\"' ); Pour ajouter le support de l'auto-incr\u00e9mentation sur un champ entier \u00e0 une table existante, on peut utiliser les commandes suivantes: 1 2 3 4 5 6 7 8 9 10 11 -- Cr\u00e9ation de la s\u00e9quence CREATE SEQUENCE monschema . test_id_seq ; -- Modification du champ pour ajouter la valeur par d\u00e9faut ALTER TABLE monschema . test ALTER COLUMN id SET DEFAULT nextval ( '\"monschema\".\"test_id_seq\"' ); -- Modification de la valeur actuelle de la s\u00e9quence au maximum du champ id SELECT setval ( '\"monschema\".\"test_id_seq\"' , ( SELECT max ( id ) FROM monschema . test )); -- D\u00e9clarer \u00e0 PostgreSQL que la s\u00e9quence et le champ sont li\u00e9s ALTER SEQUENCE monschema . test_id_seq OWNED BY monschema . test . id ; Dans l'exemple ci-dessus, le sch\u00e9ma est pr\u00e9cis\u00e9. Cr\u00e9ation automatique d'indexes spatiaux # Pour des donn\u00e9es spatiales volumineuses, les performances d'affichage sont bien meilleures \u00e0 grande \u00e9chelle si on a ajout\u00e9 un index spatial . L'index est aussi beaucoup utilis\u00e9 pour am\u00e9liorer les performances d'analyses spatiales. On peut cr\u00e9er l'index spatial table par table, ou bien automatiser cette cr\u00e9ation, c'est-\u00e0-dire cr\u00e9er les indexes spatiaux pour toutes les tables qui n'en ont pas . Pour cela, nous avons con\u00e7u une fonction, t\u00e9l\u00e9chargeable ici: https://gist.github.com/mdouchin/cfa0e37058bcf102ed490bc59d762042 On doit copier/coller le script SQL de cette page \"gist\" dans la fen\u00eatre SQL du Gestionnaire de bases de donn\u00e9es de QGIS, puis lancer la requ\u00eate avec Ex\u00e9cuter . On peut ensuite vider le contenu de la fen\u00eatre, puis appeler la fonction create_missing_spatial_indexes via le code SQL suivant: 1 2 3 4 5 6 7 8 -- On lance avec le param\u00e8tre \u00e0 True si on veut juste voir les tables qui n'ont pas d'index spatial -- On lance avec False si on veut cr\u00e9er les indexes automatiquement -- V\u00e9rification SELECT * FROM create_missing_spatial_indexes ( True ); -- Cr\u00e9ation SELECT * FROM create_missing_spatial_indexes ( False ); Trouver toutes les tables sans cl\u00e9 primaire # Il est tr\u00e8s important de d\u00e9clarer une cl\u00e9 primaire pour vos tables stock\u00e9es dans PostgreSQL. Cela fournit un moyen aux logiciels comme QGIS d'identifier de mani\u00e8re performante les lignes dans une table. Sans cl\u00e9 primaire, les performances d'acc\u00e8s aux donn\u00e9es peuvent \u00eatre d\u00e9grad\u00e9es. Vous pouvez trouver l'ensemble des tables de votre base de donn\u00e9es sans cl\u00e9 primaire en construisant cette vue PostgreSQL tables_without_primary_key : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 DROP VIEW IF EXISTS tables_without_primary_key ; CREATE VIEW tables_without_primary_key AS SELECT t . table_schema , t . table_name FROM information_schema . tables AS t LEFT JOIN information_schema . table_constraints AS c ON t . table_schema = c . table_schema AND t . table_name = c . table_name AND c . constraint_type = 'PRIMARY KEY' WHERE True AND t . table_type = 'BASE TABLE' AND t . table_schema not in ( 'pg_catalog' , 'information_schema' ) AND c . constraint_name IS NULL ORDER BY table_schema , table_name ; Pour lister les tables sans g\u00e9om\u00e9tries, vous pouvez ensuite lancer la requ\u00eate suivante: 1 2 SELECT * FROM tables_without_primary_key ; Ce qui peut donner par exemple: table_schema table_name agriculture parcelles agriculture puits cadastre sections environnement znieff environnement parcs_naturels Pour lister les tables sans g\u00e9om\u00e9tries d'un seul sch\u00e9ma, par exemple cadastre , vous pouvez ensuite lancer la requ\u00eate: 1 2 3 SELECT * FROM tables_without_primary_key WHERE table_schema IN ( 'cadastre' ); Ce qui peut alors donner: table_schema table_name cadastre sections Ajouter automatiquement plusieurs champs \u00e0 plusieurs tables # Il est parfois n\u00e9cessaire d' ajouter des champs \u00e0 une ou plusieurs tables , par exemple pour y stocker ensuite des m\u00e9tadonn\u00e9es (date de modification, date d'ajout, utilisateur, lien, etc). Nous proposons pour cela la fonction ajout_champs_dynamiques qui permet de fournir un nom de sch\u00e9ma, un nom de table, et une cha\u00eene de caract\u00e8re contenant la liste s\u00e9par\u00e9e par virgule des champs et de leur type. La fonction est accessible ici: https://gist.github.com/mdouchin/50234f1f33801aed6f4f2cbab9f4887c Exemple d'utilisation pour une table commune du sch\u00e9ma test : on ajoute les champs date_creation , date_modification et utilisateur 1 2 3 SELECT ajout_champs_dynamiques ( 'test' , 'commune' , 'date_creation timestamp DEFAULT now(), date_modification timestamp DEFAULT now(), utilisateur text' ) ; Exemple d'utilisation pour toutes les tables d'un sch\u00e9ma , ici le sch\u00e9ma test . On utilise dans cette exemple la vue geometry_columns qui liste les tables spatiales, car on souhaite aussi ne faire cet ajout que pour les donn\u00e9es de type POINT 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 -- Lancer la cr\u00e9ation de champs sur toutes les tables -- du sch\u00e9ma test -- contenant des g\u00e9om\u00e9tries de type Point SELECT f_table_schema , f_table_name , ajout_champs_dynamiques ( -- sch\u00e9ma f_table_schema , -- table f_table_name , -- liste des champs, au format nom_du_champ TYPE 'date_creation timestamp DEFAULT now(), date_modification timestamp DEFAULT now(), utilisateur text' ) FROM geometry_columns WHERE True AND \"type\" LIKE '%POINT' AND f_table_schema IN ( 'test' ) ORDER BY f_table_schema , f_table_name ; V\u00e9rifier la taille des bases, tables et sch\u00e9mas # Conna\u00eetre la taille des bases de donn\u00e9es # On peut lancer la requ\u00eate suivante, qui renvoit les bases de donn\u00e9es ordonn\u00e9es par taille descendante. 1 2 3 4 5 6 7 SELECT pg_database . datname AS db_name , pg_database_size ( pg_database . datname ) AS db_size , pg_size_pretty ( pg_database_size ( pg_database . datname )) AS db_pretty_size FROM pg_database WHERE datname NOT IN ( 'postgres' , 'template0' , 'template1' ) ORDER BY db_size DESC ; Calculer la taille des tables # On cr\u00e9e une fonction get_table_info qui utilise les tables syst\u00e8me pour lister les tables, r\u00e9cup\u00e9rer leur sch\u00e9ma et les informations de taille. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 DROP FUNCTION IF EXISTS get_table_info (); CREATE OR REPLACE FUNCTION get_table_info () RETURNS TABLE ( oid oid , schema_name text , table_name text , row_count integer , total_size bigint , pretty_total_size text ) AS $$ BEGIN RETURN QUERY SELECT b . oid , b . schema_name :: text , b . table_name :: text , b . row_count :: integer , b . total_size :: bigint , pg_size_pretty ( b . total_size ) AS pretty_total_size FROM ( SELECT * , a . total_size - index_bytes - COALESCE ( toast_bytes , 0 ) AS table_bytes FROM ( SELECT c . oid , nspname AS schema_name , relname AS TABLE_NAME , c . reltuples AS row_count , pg_total_relation_size ( c . oid ) AS total_size , pg_indexes_size ( c . oid ) AS index_bytes , pg_total_relation_size ( reltoastrelid ) AS toast_bytes FROM pg_class c LEFT JOIN pg_namespace n ON n . oid = c . relnamespace WHERE relkind = 'r' AND nspname NOT IN ( 'pg_catalog' , 'information_schema' ) ) AS a ) AS b ; END ; $$ LANGUAGE 'plpgsql' ; On peut l'utiliser simplement de la mani\u00e8re suivante 1 2 3 4 5 -- Liste les tables SELECT * FROM get_table_info () ORDER BY schema_name , table_name DESC ; -- Lister les tables dans l'ordre inverse de taille SELECT * FROM get_table_info () ORDER BY total_size DESC ; Calculer la taille des sch\u00e9mas # On cr\u00e9e une simple fonction qui renvoit la somme des tailles des tables d'un sch\u00e9ma 1 2 3 4 5 6 7 8 9 10 -- Fonction pour calculer la taille d'un sch\u00e9ma CREATE OR REPLACE FUNCTION pg_schema_size ( schema_name text ) RETURNS BIGINT AS $$ SELECT SUM ( pg_total_relation_size ( quote_ident ( schemaname ) || '.' || quote_ident ( tablename ))):: BIGINT FROM pg_tables WHERE schemaname = schema_name $$ LANGUAGE SQL ; On peut alors l'utiliser pour conna\u00eetre la taille d'un sch\u00e9ma 1 2 -- utilisation pour un sch\u00e9ma SELECT pg_size_pretty ( pg_schema_size ( 'public' )) AS ; Ou lister l'ensemble des sch\u00e9mas 1 2 3 4 5 -- lister les sch\u00e9mas et r\u00e9cup\u00e9rer leur taille SELECT schema_name , pg_size_pretty ( pg_schema_size ( schema_name )) FROM information_schema . schemata WHERE schema_name NOT IN ( 'pg_catalog' , 'information_schema' ) ORDER BY pg_schema_size ( schema_name ) DESC ; Tester les diff\u00e9rences entre 2 tables de m\u00eame structure # Nous souhaitons comparer deux tables de la base , par exemple une table de communes en 2021 communes_2021 et une table de communes en 2022 communes_2022 . On peut utiliser une fonction qui utilise les possibilit\u00e9s du format hstore pour comparer les donn\u00e9es entre elles. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 -- On ajoute le support du format hstore CREATE EXTENSION IF NOT EXISTS hstore ; -- On cr\u00e9e la fonction de comparaison DROP FUNCTION compare_tables ( text , text , text , text , text , text []); CREATE OR REPLACE FUNCTION compare_tables ( p_schema_name_a text , p_table_name_a text , p_schema_name_b text , p_table_name_b text , p_common_identifier_field text , p_excluded_fields text [] ) RETURNS TABLE ( uid text , status text , table_a_values hstore , table_b_values hstore ) LANGUAGE plpgsql AS $ _$ DECLARE sqltemplate text ; BEGIN -- Compare data sqltemplate = ' SELECT coalesce(ta.\"%1$s\", tb.\"%1$s\") AS \"%1$s\", CASE WHEN ta.\"%1$s\" IS NULL THEN ''not in table A'' WHEN tb.\"%1$s\" IS NULL THEN ''not in table B'' ELSE ''table A != table B'' END AS status, CASE WHEN ta.\"%1$s\" IS NULL THEN NULL ELSE (hstore(ta.*) - ''%6$s''::text[]) - (hstore(tb) - ''%6$s''::text[]) END AS values_in_table_a, CASE WHEN tb.\"%1$s\" IS NULL THEN NULL ELSE (hstore(tb.*) - ''%6$s''::text[]) - (hstore(ta) - ''%6$s''::text[]) END AS values_in_table_b FROM \"%2$s\".\"%3$s\" AS ta FULL JOIN \"%4$s\".\"%5$s\" AS tb ON ta.\"%1$s\" = tb.\"%1$s\" WHERE (hstore(ta.*) - ''%6$s''::text[]) != (hstore(tb.*) - ''%6$s''::text[]) OR (ta.\"%1$s\" IS NULL) OR (tb.\"%1$s\" IS NULL) ' ; RETURN QUERY EXECUTE format ( sqltemplate , p_common_identifier_field , p_schema_name_a , p_table_name_a , p_schema_name_b , p_table_name_b , p_excluded_fields ); END ; $ _$ ; Cette fonction attend en param\u00e8tres le sch\u00e9ma de la table A . Ex: referentiels le nom de la table A . Ex: communes_2021 le sch\u00e9ma de la table B . Ex: referentiels le nom de la table B . Ex: communes_2022 le nom du champ qui identifie de mani\u00e8re unique la donn\u00e9e. Ce n'est pas forc\u00e9ment la cl\u00e9 primaire. Ex code_commune un tableau de champs pour lesquels ne pas v\u00e9rifier les diff\u00e9rences. Ex: array['region', 'departement'] La requ\u00eate \u00e0 lancer est la suivantes 1 2 3 4 5 6 7 8 9 SELECT \"uid\" , \"status\" , \"table_a_values\" , \"table_b_values\" FROM compare_tables ( 'referentiels' , 'commune_2021' , 'referentiels' , 'commune_2022' , 'code_commune' , array [ 'region' , 'departement' ] ) ORDER BY status , uid ; Exemple de donn\u00e9es renvoy\u00e9es: uid status table_a_values table_b_values 12345 not in table A NULL \"annee_ref\"=>\"2022\", \"nom_commune\"=>\"Nouvelle commune\", \"population\"=>\"5723\" 97612 not in table B \"annee_ref\"=>\"2021\", \"nom_commune\"=>\"Ancienne commune\", \"population\"=>\"840\" NULL 97602 table A != table B \"annee_ref\"=>\"2021\", \"population\"=>\"1245\" \"annee_ref\"=>\"2022\", \"population\"=>\"1322\" Dans l'affichage ci-dessus, je n'ai pas affich\u00e9 le champ de g\u00e9om\u00e9trie, mais la fonction teste aussi les diff\u00e9rences de g\u00e9om\u00e9tries. Attention, les performances de ce type de requ\u00eate ne sont pas forc\u00e9ment assur\u00e9es pour des volumes de donn\u00e9es importants. Lister les triggers appliqu\u00e9s sur les tables # On peut utiliser la requ\u00eate suivante pour lister l'ensemble des triggers activ\u00e9s sur les tables 1 2 3 4 5 6 7 8 9 10 11 12 13 SELECT event_object_schema AS table_schema , event_object_table AS table_name , trigger_schema , trigger_name , string_agg ( event_manipulation , ',' ) AS event , action_timing AS activation , action_condition AS condition , action_statement AS definition FROM information_schema . triggers GROUP BY 1 , 2 , 3 , 4 , 6 , 7 , 8 ORDER BY table_schema , table_name ; Continuer vers Gestion des droits","title":"Fonctions utiles"},{"location":"utils/#fonctions-utiles","text":"Nous regroupons ici quelques fonctions r\u00e9alis\u00e9es au cours de formations ou d'accompagnements d'utilisateurs de PostgreSQL.","title":"Fonctions utiles"},{"location":"utils/#ajout-de-lauto-incrementation-sur-un-champ-entier","text":"Lorsqu'on importe une couche dans une table via les outils de QGIS, le champ d'identifiant choisi n'a pas le support de l'auto-incr\u00e9mentation, ce qui peut poser des probl\u00e8mes de l'ajout de nouvelles donn\u00e9es. Par exemple, pour une s\u00e9quence monschema.ma_sequence , si la requ\u00eate suivante \u00e9choue, c'est que la s\u00e9quence n'est en effet pas correctement configur\u00e9e : 1 SELECT currval ( '\"monschema\".\"test_id_seq\"' ); Pour ajouter le support de l'auto-incr\u00e9mentation sur un champ entier \u00e0 une table existante, on peut utiliser les commandes suivantes: 1 2 3 4 5 6 7 8 9 10 11 -- Cr\u00e9ation de la s\u00e9quence CREATE SEQUENCE monschema . test_id_seq ; -- Modification du champ pour ajouter la valeur par d\u00e9faut ALTER TABLE monschema . test ALTER COLUMN id SET DEFAULT nextval ( '\"monschema\".\"test_id_seq\"' ); -- Modification de la valeur actuelle de la s\u00e9quence au maximum du champ id SELECT setval ( '\"monschema\".\"test_id_seq\"' , ( SELECT max ( id ) FROM monschema . test )); -- D\u00e9clarer \u00e0 PostgreSQL que la s\u00e9quence et le champ sont li\u00e9s ALTER SEQUENCE monschema . test_id_seq OWNED BY monschema . test . id ; Dans l'exemple ci-dessus, le sch\u00e9ma est pr\u00e9cis\u00e9.","title":"Ajout de l'auto-incr\u00e9mentation sur un champ entier"},{"location":"utils/#creation-automatique-dindexes-spatiaux","text":"Pour des donn\u00e9es spatiales volumineuses, les performances d'affichage sont bien meilleures \u00e0 grande \u00e9chelle si on a ajout\u00e9 un index spatial . L'index est aussi beaucoup utilis\u00e9 pour am\u00e9liorer les performances d'analyses spatiales. On peut cr\u00e9er l'index spatial table par table, ou bien automatiser cette cr\u00e9ation, c'est-\u00e0-dire cr\u00e9er les indexes spatiaux pour toutes les tables qui n'en ont pas . Pour cela, nous avons con\u00e7u une fonction, t\u00e9l\u00e9chargeable ici: https://gist.github.com/mdouchin/cfa0e37058bcf102ed490bc59d762042 On doit copier/coller le script SQL de cette page \"gist\" dans la fen\u00eatre SQL du Gestionnaire de bases de donn\u00e9es de QGIS, puis lancer la requ\u00eate avec Ex\u00e9cuter . On peut ensuite vider le contenu de la fen\u00eatre, puis appeler la fonction create_missing_spatial_indexes via le code SQL suivant: 1 2 3 4 5 6 7 8 -- On lance avec le param\u00e8tre \u00e0 True si on veut juste voir les tables qui n'ont pas d'index spatial -- On lance avec False si on veut cr\u00e9er les indexes automatiquement -- V\u00e9rification SELECT * FROM create_missing_spatial_indexes ( True ); -- Cr\u00e9ation SELECT * FROM create_missing_spatial_indexes ( False );","title":"Cr\u00e9ation automatique d'indexes spatiaux"},{"location":"utils/#trouver-toutes-les-tables-sans-cle-primaire","text":"Il est tr\u00e8s important de d\u00e9clarer une cl\u00e9 primaire pour vos tables stock\u00e9es dans PostgreSQL. Cela fournit un moyen aux logiciels comme QGIS d'identifier de mani\u00e8re performante les lignes dans une table. Sans cl\u00e9 primaire, les performances d'acc\u00e8s aux donn\u00e9es peuvent \u00eatre d\u00e9grad\u00e9es. Vous pouvez trouver l'ensemble des tables de votre base de donn\u00e9es sans cl\u00e9 primaire en construisant cette vue PostgreSQL tables_without_primary_key : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 DROP VIEW IF EXISTS tables_without_primary_key ; CREATE VIEW tables_without_primary_key AS SELECT t . table_schema , t . table_name FROM information_schema . tables AS t LEFT JOIN information_schema . table_constraints AS c ON t . table_schema = c . table_schema AND t . table_name = c . table_name AND c . constraint_type = 'PRIMARY KEY' WHERE True AND t . table_type = 'BASE TABLE' AND t . table_schema not in ( 'pg_catalog' , 'information_schema' ) AND c . constraint_name IS NULL ORDER BY table_schema , table_name ; Pour lister les tables sans g\u00e9om\u00e9tries, vous pouvez ensuite lancer la requ\u00eate suivante: 1 2 SELECT * FROM tables_without_primary_key ; Ce qui peut donner par exemple: table_schema table_name agriculture parcelles agriculture puits cadastre sections environnement znieff environnement parcs_naturels Pour lister les tables sans g\u00e9om\u00e9tries d'un seul sch\u00e9ma, par exemple cadastre , vous pouvez ensuite lancer la requ\u00eate: 1 2 3 SELECT * FROM tables_without_primary_key WHERE table_schema IN ( 'cadastre' ); Ce qui peut alors donner: table_schema table_name cadastre sections","title":"Trouver toutes les tables sans cl\u00e9 primaire"},{"location":"utils/#ajouter-automatiquement-plusieurs-champs-a-plusieurs-tables","text":"Il est parfois n\u00e9cessaire d' ajouter des champs \u00e0 une ou plusieurs tables , par exemple pour y stocker ensuite des m\u00e9tadonn\u00e9es (date de modification, date d'ajout, utilisateur, lien, etc). Nous proposons pour cela la fonction ajout_champs_dynamiques qui permet de fournir un nom de sch\u00e9ma, un nom de table, et une cha\u00eene de caract\u00e8re contenant la liste s\u00e9par\u00e9e par virgule des champs et de leur type. La fonction est accessible ici: https://gist.github.com/mdouchin/50234f1f33801aed6f4f2cbab9f4887c Exemple d'utilisation pour une table commune du sch\u00e9ma test : on ajoute les champs date_creation , date_modification et utilisateur 1 2 3 SELECT ajout_champs_dynamiques ( 'test' , 'commune' , 'date_creation timestamp DEFAULT now(), date_modification timestamp DEFAULT now(), utilisateur text' ) ; Exemple d'utilisation pour toutes les tables d'un sch\u00e9ma , ici le sch\u00e9ma test . On utilise dans cette exemple la vue geometry_columns qui liste les tables spatiales, car on souhaite aussi ne faire cet ajout que pour les donn\u00e9es de type POINT 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 -- Lancer la cr\u00e9ation de champs sur toutes les tables -- du sch\u00e9ma test -- contenant des g\u00e9om\u00e9tries de type Point SELECT f_table_schema , f_table_name , ajout_champs_dynamiques ( -- sch\u00e9ma f_table_schema , -- table f_table_name , -- liste des champs, au format nom_du_champ TYPE 'date_creation timestamp DEFAULT now(), date_modification timestamp DEFAULT now(), utilisateur text' ) FROM geometry_columns WHERE True AND \"type\" LIKE '%POINT' AND f_table_schema IN ( 'test' ) ORDER BY f_table_schema , f_table_name ;","title":"Ajouter automatiquement plusieurs champs \u00e0 plusieurs tables"},{"location":"utils/#verifier-la-taille-des-bases-tables-et-schemas","text":"","title":"V\u00e9rifier la taille des bases, tables et sch\u00e9mas"},{"location":"utils/#connaitre-la-taille-des-bases-de-donnees","text":"On peut lancer la requ\u00eate suivante, qui renvoit les bases de donn\u00e9es ordonn\u00e9es par taille descendante. 1 2 3 4 5 6 7 SELECT pg_database . datname AS db_name , pg_database_size ( pg_database . datname ) AS db_size , pg_size_pretty ( pg_database_size ( pg_database . datname )) AS db_pretty_size FROM pg_database WHERE datname NOT IN ( 'postgres' , 'template0' , 'template1' ) ORDER BY db_size DESC ;","title":"Conna\u00eetre la taille des bases de donn\u00e9es"},{"location":"utils/#calculer-la-taille-des-tables","text":"On cr\u00e9e une fonction get_table_info qui utilise les tables syst\u00e8me pour lister les tables, r\u00e9cup\u00e9rer leur sch\u00e9ma et les informations de taille. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 DROP FUNCTION IF EXISTS get_table_info (); CREATE OR REPLACE FUNCTION get_table_info () RETURNS TABLE ( oid oid , schema_name text , table_name text , row_count integer , total_size bigint , pretty_total_size text ) AS $$ BEGIN RETURN QUERY SELECT b . oid , b . schema_name :: text , b . table_name :: text , b . row_count :: integer , b . total_size :: bigint , pg_size_pretty ( b . total_size ) AS pretty_total_size FROM ( SELECT * , a . total_size - index_bytes - COALESCE ( toast_bytes , 0 ) AS table_bytes FROM ( SELECT c . oid , nspname AS schema_name , relname AS TABLE_NAME , c . reltuples AS row_count , pg_total_relation_size ( c . oid ) AS total_size , pg_indexes_size ( c . oid ) AS index_bytes , pg_total_relation_size ( reltoastrelid ) AS toast_bytes FROM pg_class c LEFT JOIN pg_namespace n ON n . oid = c . relnamespace WHERE relkind = 'r' AND nspname NOT IN ( 'pg_catalog' , 'information_schema' ) ) AS a ) AS b ; END ; $$ LANGUAGE 'plpgsql' ; On peut l'utiliser simplement de la mani\u00e8re suivante 1 2 3 4 5 -- Liste les tables SELECT * FROM get_table_info () ORDER BY schema_name , table_name DESC ; -- Lister les tables dans l'ordre inverse de taille SELECT * FROM get_table_info () ORDER BY total_size DESC ;","title":"Calculer la taille des tables"},{"location":"utils/#calculer-la-taille-des-schemas","text":"On cr\u00e9e une simple fonction qui renvoit la somme des tailles des tables d'un sch\u00e9ma 1 2 3 4 5 6 7 8 9 10 -- Fonction pour calculer la taille d'un sch\u00e9ma CREATE OR REPLACE FUNCTION pg_schema_size ( schema_name text ) RETURNS BIGINT AS $$ SELECT SUM ( pg_total_relation_size ( quote_ident ( schemaname ) || '.' || quote_ident ( tablename ))):: BIGINT FROM pg_tables WHERE schemaname = schema_name $$ LANGUAGE SQL ; On peut alors l'utiliser pour conna\u00eetre la taille d'un sch\u00e9ma 1 2 -- utilisation pour un sch\u00e9ma SELECT pg_size_pretty ( pg_schema_size ( 'public' )) AS ; Ou lister l'ensemble des sch\u00e9mas 1 2 3 4 5 -- lister les sch\u00e9mas et r\u00e9cup\u00e9rer leur taille SELECT schema_name , pg_size_pretty ( pg_schema_size ( schema_name )) FROM information_schema . schemata WHERE schema_name NOT IN ( 'pg_catalog' , 'information_schema' ) ORDER BY pg_schema_size ( schema_name ) DESC ;","title":"Calculer la taille des sch\u00e9mas"},{"location":"utils/#tester-les-differences-entre-2-tables-de-meme-structure","text":"Nous souhaitons comparer deux tables de la base , par exemple une table de communes en 2021 communes_2021 et une table de communes en 2022 communes_2022 . On peut utiliser une fonction qui utilise les possibilit\u00e9s du format hstore pour comparer les donn\u00e9es entre elles. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 -- On ajoute le support du format hstore CREATE EXTENSION IF NOT EXISTS hstore ; -- On cr\u00e9e la fonction de comparaison DROP FUNCTION compare_tables ( text , text , text , text , text , text []); CREATE OR REPLACE FUNCTION compare_tables ( p_schema_name_a text , p_table_name_a text , p_schema_name_b text , p_table_name_b text , p_common_identifier_field text , p_excluded_fields text [] ) RETURNS TABLE ( uid text , status text , table_a_values hstore , table_b_values hstore ) LANGUAGE plpgsql AS $ _$ DECLARE sqltemplate text ; BEGIN -- Compare data sqltemplate = ' SELECT coalesce(ta.\"%1$s\", tb.\"%1$s\") AS \"%1$s\", CASE WHEN ta.\"%1$s\" IS NULL THEN ''not in table A'' WHEN tb.\"%1$s\" IS NULL THEN ''not in table B'' ELSE ''table A != table B'' END AS status, CASE WHEN ta.\"%1$s\" IS NULL THEN NULL ELSE (hstore(ta.*) - ''%6$s''::text[]) - (hstore(tb) - ''%6$s''::text[]) END AS values_in_table_a, CASE WHEN tb.\"%1$s\" IS NULL THEN NULL ELSE (hstore(tb.*) - ''%6$s''::text[]) - (hstore(ta) - ''%6$s''::text[]) END AS values_in_table_b FROM \"%2$s\".\"%3$s\" AS ta FULL JOIN \"%4$s\".\"%5$s\" AS tb ON ta.\"%1$s\" = tb.\"%1$s\" WHERE (hstore(ta.*) - ''%6$s''::text[]) != (hstore(tb.*) - ''%6$s''::text[]) OR (ta.\"%1$s\" IS NULL) OR (tb.\"%1$s\" IS NULL) ' ; RETURN QUERY EXECUTE format ( sqltemplate , p_common_identifier_field , p_schema_name_a , p_table_name_a , p_schema_name_b , p_table_name_b , p_excluded_fields ); END ; $ _$ ; Cette fonction attend en param\u00e8tres le sch\u00e9ma de la table A . Ex: referentiels le nom de la table A . Ex: communes_2021 le sch\u00e9ma de la table B . Ex: referentiels le nom de la table B . Ex: communes_2022 le nom du champ qui identifie de mani\u00e8re unique la donn\u00e9e. Ce n'est pas forc\u00e9ment la cl\u00e9 primaire. Ex code_commune un tableau de champs pour lesquels ne pas v\u00e9rifier les diff\u00e9rences. Ex: array['region', 'departement'] La requ\u00eate \u00e0 lancer est la suivantes 1 2 3 4 5 6 7 8 9 SELECT \"uid\" , \"status\" , \"table_a_values\" , \"table_b_values\" FROM compare_tables ( 'referentiels' , 'commune_2021' , 'referentiels' , 'commune_2022' , 'code_commune' , array [ 'region' , 'departement' ] ) ORDER BY status , uid ; Exemple de donn\u00e9es renvoy\u00e9es: uid status table_a_values table_b_values 12345 not in table A NULL \"annee_ref\"=>\"2022\", \"nom_commune\"=>\"Nouvelle commune\", \"population\"=>\"5723\" 97612 not in table B \"annee_ref\"=>\"2021\", \"nom_commune\"=>\"Ancienne commune\", \"population\"=>\"840\" NULL 97602 table A != table B \"annee_ref\"=>\"2021\", \"population\"=>\"1245\" \"annee_ref\"=>\"2022\", \"population\"=>\"1322\" Dans l'affichage ci-dessus, je n'ai pas affich\u00e9 le champ de g\u00e9om\u00e9trie, mais la fonction teste aussi les diff\u00e9rences de g\u00e9om\u00e9tries. Attention, les performances de ce type de requ\u00eate ne sont pas forc\u00e9ment assur\u00e9es pour des volumes de donn\u00e9es importants.","title":"Tester les diff\u00e9rences entre 2 tables de m\u00eame structure"},{"location":"utils/#lister-les-triggers-appliques-sur-les-tables","text":"On peut utiliser la requ\u00eate suivante pour lister l'ensemble des triggers activ\u00e9s sur les tables 1 2 3 4 5 6 7 8 9 10 11 12 13 SELECT event_object_schema AS table_schema , event_object_table AS table_name , trigger_schema , trigger_name , string_agg ( event_manipulation , ',' ) AS event , action_timing AS activation , action_condition AS condition , action_statement AS definition FROM information_schema . triggers GROUP BY 1 , 2 , 3 , 4 , 6 , 7 , 8 ORDER BY table_schema , table_name ; Continuer vers Gestion des droits","title":"Lister les triggers appliqu\u00e9s sur les tables"},{"location":"validate_geometries/","text":"Correction des g\u00e9om\u00e9tries # Avec PostgreSQL on peut tester la validit\u00e9 des g\u00e9om\u00e9tries d'une table, comprendre la raison et localiser les soucis de validit\u00e9: 1 2 3 4 5 6 7 8 9 10 SELECT id_parcelle , -- v\u00e9rifier si la g\u00e9om est valide ST_IsValid ( geom ) AS validite_geom , -- connaitre la raison d'invalidit\u00e9 st_isvalidreason ( geom ) AS validite_raison , -- sortir un point qui localise le souci de validit\u00e9 ST_SetSRID ( location ( st_isvaliddetail ( geom )), 2154 ) AS geom FROM z_formation . parcelle_havre WHERE ST_IsValid ( geom ) IS FALSE qui renvoit 2 erreurs de polygones crois\u00e9s. id_parcelle validite_geom validite_raison point_invalide 707847 False Self-intersection[492016.260004897 6938870.66384629] 010100000041B93E0AC1071E4122757CAA3D785A41 742330 False Self-intersection[489317.48266784 6939616.89391708] 0101000000677A40EE95DD1D41FBEF3539F8785A41 et qu'on peut ouvrir comme une nouvelle couche, avec le champ g\u00e9om\u00e9trie point_invalide , ce qui permet de visualiser dans QGIS les positions des erreurs. PostGIS fournir l'outil ST_MakeValid pour corriger automatiquement les g\u00e9om\u00e9tries invalides. On peut l'utiliser pour les lignes et polygones. Attention, pour les polygones, cela peut conduire \u00e0 des g\u00e9om\u00e9tries de type diff\u00e9rent (par exemple une polygone \u00e0 2 noeuds devient une ligne). On utilise donc aussi la fonction ST_CollectionExtract pour ne r\u00e9cup\u00e9rer que les polygones. 1 2 3 4 5 6 7 8 9 -- Corriger les g\u00e9om\u00e9tries UPDATE z_formation . parcelle_havre SET geom = ST_Multi ( ST_CollectionExtract ( ST_MakeValid ( geom ), 3 )) WHERE NOT ST_isvalid ( geom ) -- Tester SELECT count ( * ) FROM z_formation . parcelle_havre WHERE NOT ST_isvalid ( geom ) Il faut aussi supprimer l'ensemble des lignes dans la table qui ne correspondent pas au type de la couche import\u00e9e. Par exemple, pour les polygones, supprimer les objets dont le nombre de noeuds est inf\u00e9rieur \u00e0 3. On les trouve: 1 2 3 SELECT * FROM z_formation . parcelle_havre WHERE ST_NPoints ( geom ) < 3 On les supprime: 1 2 3 DELETE FROM z_formation . parcelle_havre WHERE ST_NPoints ( geom ) < 3 Continuer vers V\u00e9rifier la topologie","title":"Correction g\u00e9om\u00e9tries"},{"location":"validate_geometries/#correction-des-geometries","text":"Avec PostgreSQL on peut tester la validit\u00e9 des g\u00e9om\u00e9tries d'une table, comprendre la raison et localiser les soucis de validit\u00e9: 1 2 3 4 5 6 7 8 9 10 SELECT id_parcelle , -- v\u00e9rifier si la g\u00e9om est valide ST_IsValid ( geom ) AS validite_geom , -- connaitre la raison d'invalidit\u00e9 st_isvalidreason ( geom ) AS validite_raison , -- sortir un point qui localise le souci de validit\u00e9 ST_SetSRID ( location ( st_isvaliddetail ( geom )), 2154 ) AS geom FROM z_formation . parcelle_havre WHERE ST_IsValid ( geom ) IS FALSE qui renvoit 2 erreurs de polygones crois\u00e9s. id_parcelle validite_geom validite_raison point_invalide 707847 False Self-intersection[492016.260004897 6938870.66384629] 010100000041B93E0AC1071E4122757CAA3D785A41 742330 False Self-intersection[489317.48266784 6939616.89391708] 0101000000677A40EE95DD1D41FBEF3539F8785A41 et qu'on peut ouvrir comme une nouvelle couche, avec le champ g\u00e9om\u00e9trie point_invalide , ce qui permet de visualiser dans QGIS les positions des erreurs. PostGIS fournir l'outil ST_MakeValid pour corriger automatiquement les g\u00e9om\u00e9tries invalides. On peut l'utiliser pour les lignes et polygones. Attention, pour les polygones, cela peut conduire \u00e0 des g\u00e9om\u00e9tries de type diff\u00e9rent (par exemple une polygone \u00e0 2 noeuds devient une ligne). On utilise donc aussi la fonction ST_CollectionExtract pour ne r\u00e9cup\u00e9rer que les polygones. 1 2 3 4 5 6 7 8 9 -- Corriger les g\u00e9om\u00e9tries UPDATE z_formation . parcelle_havre SET geom = ST_Multi ( ST_CollectionExtract ( ST_MakeValid ( geom ), 3 )) WHERE NOT ST_isvalid ( geom ) -- Tester SELECT count ( * ) FROM z_formation . parcelle_havre WHERE NOT ST_isvalid ( geom ) Il faut aussi supprimer l'ensemble des lignes dans la table qui ne correspondent pas au type de la couche import\u00e9e. Par exemple, pour les polygones, supprimer les objets dont le nombre de noeuds est inf\u00e9rieur \u00e0 3. On les trouve: 1 2 3 SELECT * FROM z_formation . parcelle_havre WHERE ST_NPoints ( geom ) < 3 On les supprime: 1 2 3 DELETE FROM z_formation . parcelle_havre WHERE ST_NPoints ( geom ) < 3 Continuer vers V\u00e9rifier la topologie","title":"Correction des g\u00e9om\u00e9tries"}]}